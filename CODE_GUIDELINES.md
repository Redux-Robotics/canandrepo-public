# Code guidelines

These are guidelines rather than hard rules.
Redux codebases can and will violate them a lot.

But as we exceed 100k lines of Rust, we do have to think about how to make maintenance of our vast codebase more managable for ourselves.
So these guidelines exist not as hard rules but rather general preferences to lean towards.

## Types and encapsulation

Types are good. Use them. Use them a lot. 

If you've ever written C before, you've probably had a million variables lying around everywhere containing all your state. 
And while you probably know how it works right now, the next person to read your code (which could very well be you) is gonna have to figure it out.
Ts pmo

So in general, **if you have groups of related variables that represent a Thing, you should throw them into a struct.**

Structs are generally "fake" in Rust unless they're some `repr(C)` stuff that gets transmuted into an array.
The compiler will aggressively un-encapsulate your structs into reasonable machine code.

**Do not be afraid to nest structs.** Splitting things up into smaller abstractions is okay. Things are allowed to have complex state.

## Struct field accesses and encapsulation

```rust
struct Thing {
    pub field_a: u32,
    pub field_b: u32,
}

pub fn avoid_this(a: &mut Thing) {
    // If you find yourself mutating multiple fields within a struct at a time, it's probably a good idea to refactor
    // this into a function on the struct itself.

    // A lot of older Redux code doesn't do this and it's a migrane speedrun any%
    let old = a.field_a;
    a.field_a = some_computation_a();
    a.field_b = some_computation_b() + old;
}

impl Thing {
    // you should probably do this instead and then call `a.update_computation(...)`
    pub fn update_computation(&mut self) {
        let old = self.field_a;
        self.field_a = some_computation_a();
        self.field_b = some_computation_b() + old;

    }
}

```

You don't have to go full Java getters/setters, but especially if there's some invariants on your struct you want to preserve, it should have a dedicated mutator.

If you're implementing something on an existing type (e.g. autogenerated RTIC context structs), you can always use newtypes or make up traits to impl on the spot.

## RTIC scoped locks

Following on from the previous section, RTIC scoped locks should generally consist of single function calls.
**Generally speaking, do not put state logic updates in those closures.**

```rust
pub async fn thing(mut cx: Thing::Context<'_>) {
    // Do:
    cx.shared.state.lock(|state| state.thing_update(params));

    // Avoid:
    cx.shared.state.lock(|state| {
        // begin thing_update
        state.params1 = params.1;
        state.params2 = params.1;
        state.other_thing();
        // end thing_update
    });

}
```

The mental model of how RTIC scoped locks work is that they're "scoped critical sections" -- they mask out all other tasks that could potentially
screw with the piece of data you're locking.
The lock acquisition/release mechanism is single-cycle, but time you spend in that task is time that cannot be preempted by interrupts or software tasks that may use it.

## Sum types/enums

Good code uses sum types, and the more sum types it uses, the more good the code is. Hope this helps :thumbs_up:
```rust

#[derive(Copy)]
enum Thing {
    Disabled,
    Enabled(u32),
}

// Don't be afraid to treat your enum as like an immutable record type like you're some FP ivory tower academic.
// The compiler will make this sane code. there's no garbage collector to make this unperformant
impl Thing {
    pub fn update(self, thing_to_add_maybe: u32) -> Self {
        match self {
            Self::Disabled => Self::Disabled,
            Self::Enabled(v) => Self::Enabled(v + thing_to_add_maybe)
        }
    }
}

fn foo() {
    let mut a = Thing::Enabled(42);
    a = a.update(52);
}
```

One thing I did learn the hard way through Canandmessage is that you should generally avoid having struct variants on your enums, in favor of wrapping a single struct.
That is,

```rust
struct ThingYouShouldDo {
    a: u32,
    b: f32
}

enum Thing{
    DontDoThis {
        a: u32,
        b: f32,
    },
    DoThisInstead(ThingYouShouldDo),
    ImJustHereManOkay    
}
```

Why? Simple. It's a lot easier to pass a `ThingYouShouldDo` around, implement traits on it, and do all sorts of stuff with it decoupled from the enum.
If you have to match on your enum every time you want to pull one value out from one variant, that's where a lot of the enum frustration starts.

## Lints

We're not lint-obsessed but there's a couple useful ones. Especially the ones that _aren't_ from Clippy, you should give pause before disabling them.

### Things to avoid disabling

```rust
// Don't do these
#![allow(unused)] // because those yellow squiggles are reasonable signifiers that something is half-implemented


pub mod hal {
    // These are acceptable for bindgen output which often violate these rules, but please avoid applying them globally.
    #![allow(non_upper_case_globals)]
    #![allow(non_camel_case_types)]
    #![allow(non_snake_case)]
    include!(concat!(env!("OUT_DIR"), "/bindings.rs"));
}
```

### Clippy lints

Clippy lints are only to be enforced if they provide a rust-analyzer autocorrect. Anything else is likely excessive.
Things like "yeah don't do `if condition { return true } else { return false }`" sure but `clippy::type_complexity` may not be appropriate.

Many of Clippy's lints may end up reducing readability; use them responsibly and please don't unconditionally enable `clippy::pedantic` or `clippy::nursery`

## Pointer provenance

We write a lot of unsafe/unsound code.
This is just a reminder that if you alias into a `const` or `static`, you should be careful to ensure that the compiler is not inlining your memory accesses. 
This has bit me a couple times. 

## Division

Avoid division when possible. 

Division is:

* slow (takes up to 14 cycles on Cortex-M4F)
* has the potential to produce `NaN`s (for floats) or `HardFault` crashes (for integers)

### Constants

Instead of dividing by constants, define constants with a `1.0/x` factor and multiply by that instead.

LLVM is generally pretty conservative about doing this intrinsically (as there are nerd-emoji precision implications)
so you pretty much always have to do it explicitly.

```rust
const THING: f32 = 1.0 / (2.0e+12);

fn thing() -> f32 {
    THING * 4.0
}
```

You can also use inline const blocks:
```rust
// Don't:
let thing = 40.3_f32 / 42.0;
// Do:
let thing = 40.3_f32 * const { 1.0_f32 / 42.0_f32 };

```

Also consider playing around with [algebraic operations](https://github.com/rust-lang/rust/issues/136469), which ostensibly should compile out division if possible.

### Division by variables

Values acting as divisors need a check to ensure that they are not zero (for ints) or have an absolute value greater than some epsilon (for floats).
**Do not blindly divide a value** unless you're damn sure it cannot be zero, or if a `NaN` isn't gonna blow up the board.

* For integers, use [`checked_div`](https://doc.rust-lang.org/std/index.html?search=checked_div)
* For floats, check your output using [`is_finite()`](https://doc.rust-lang.org/std/primitive.f32.html#method.is_finite) on your result or clamp your divisor above some epsilon.

## Modulo

Modulo operations are extremely cursed on ARM platforms.
Avoid using them.

Modulo by power of 2 is fine as LLVM will compile this down to an AND mask

## `libm` sucks

Avoid using routines from `libm` where possible.
In particular:

* `sin` and `cos` are _excruciatingly_ slow on Cortex-M4F
* Other trig operations are less bad but they're still pretty dogwater

`libmoo` provides the following:

* Efficient computation of `sin`, `cos`, and both `sin` and `cos` at once
* A pure f32 `atan2f` impl
* A pure f32 `logf` impl
* Re-exports of LLVM compiler intrinsics (although `core_float_math` now exists)

## Panic safety

All uses of `unwrap()` that are not:

* slice/array munging with `try_into().unwrap()`
* init code that would explode otherwise

must have a comment documenting why it is infallible and will never panic.

```rust
const STATIC_PARAM: usize = 3;
// SAFETY: will not panic because STATIC_PARAM makes it such [explain]
let peripheral = Peripheral::new().unwrap(STATIC_PARAM);
```

Production firmware should ideally never panic.