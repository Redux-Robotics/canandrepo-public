#![allow(unused)] // sigh
use std::path::Path;

use canandmessage_parser::{DType, Device};
use darling::{ast::NestedMeta, Error, FromMeta};
use proc_macro::TokenStream;
use quote::format_ident;
use quote::quote;
use quote::ToTokens;

mod ui;

#[derive(Debug, FromMeta)]
struct AlchemistTSMacroArgs {
    #[darling(multiple)]
    src_file: Vec<String>,
}

#[proc_macro_attribute]
pub fn gen_typescript_utils(args: TokenStream, input: TokenStream) -> TokenStream {
    let attr_args = match NestedMeta::parse_meta_list(args.into()) {
        Ok(v) => v,
        Err(e) => {
            return TokenStream::from(Error::from(e).write_errors());
        }
    };
    let mut input = syn::parse_macro_input!(input as syn::ItemMod);

    let args = match AlchemistTSMacroArgs::from_list(&attr_args) {
        Ok(v) => v,
        Err(e) => {
            return TokenStream::from(e.write_errors());
        }
    };

    let mut devices: Vec<Device> = Vec::new();

    let proj_root = std::env::var_os("CARGO_MANIFEST_DIR").unwrap_or_default();
    for spec in args.src_file.iter() {
        devices.push(
            match canandmessage_parser::parse_spec(&Path::new(&proj_root).join(spec)) {
                Ok(v) => v.into(),
                Err(e) => {
                    return TokenStream::from(
                        darling::Error::custom(e.to_string())
                            .with_span(&spec)
                            .write_errors(),
                    );
                }
            },
        );
    }

    let funcs: Vec<proc_macro2::TokenStream> = devices
        .iter()
        .filter_map(|dev| {
            let devname = format_ident!("generate_{}_typescript", dev.name);

            let contents_str = generate_typescript_struct(&dev);

            Some(quote!(
                pub fn #devname () -> String {
                    #contents_str.to_string()
                }
            ))
        })
        .collect();

    let returnval = quote!(
        #(#funcs)*
    );

    input
        .content
        .as_mut()
        .unwrap()
        .1
        .push(syn::Item::Verbatim(returnval));

    return TokenStream::from(input.to_token_stream());
}

fn generate_typescript_struct(dev: &Device) -> String {
    let mut main_str: String = format!("{}", generate_main_struct(&dev));
    main_str += &generate_settings(&dev);
    main_str += &generate_classes(&dev);
    main_str += &generate_enums(&dev);
    main_str += &generate_bitset(&dev);

    return tabify(&main_str);
}

fn generate_main_struct(dev: &Device) -> String {
    let mut main_struct_name: String = format!("export class {} {{\n", dev.name);

    for message in dev.messages.iter() {
        for signal in message.1.signals.iter() {
            match signal.dtype {
                DType::None => continue,
                DType::Pad { width } => continue,
                _ => {
                    main_struct_name += &format!(
                        "{}_{}: {} = {}\n",
                        screaming_snake_to_camel(message.0),
                        signal.name,
                        type_from_dtype(&signal.dtype),
                        make_default(&signal.dtype)
                    );
                }
            }
        }
    }
    main_struct_name += &format!(
        "in_id_conflict: boolean = false;\nsettings: {}Settings = new {}Settings();\n",
        dev.name, dev.name
    );
    main_struct_name += "}\n\n";

    return main_struct_name;
}

fn generate_settings(dev: &Device) -> String {
    let mut struct_name: String = format!("export class {}Settings {{\n", dev.name);

    for setting in dev.settings.iter() {
        match setting.1.dtype {
            DType::None => continue,
            DType::Pad { width } => continue,
            _ => {
                struct_name += &format!(
                    "{}: {} = {}\n",
                    screaming_snake_to_camel(setting.0),
                    type_from_dtype(&setting.1.dtype),
                    make_default(&setting.1.dtype)
                );
            }
        }
    }
    struct_name += "\n";
    //--------JAVA CODEGEN--------
    struct_name += "//These methods are autogenerated. Fix it in Canandmessage.\n";
    struct_name += "generate_java_codegen(devname: String): String {\n";
    struct_name += "let javaOutStr = `${devname}.resetFactoryDefaults();\\n`\n";
    struct_name += &format!(
        "javaOutStr += `{}.Settings ${{devname}}Settings = new {}.Settings();\\n`\n",
        dev.name, dev.name
    );

    for setting in dev.settings.iter() {
        if setting.1.vdep_setting && setting.1.vendordep {
            match &setting.1.dtype {
                DType::None => continue,
                DType::Pad { width } => continue,
                _ => {
                    struct_name += &format!(
                        "if (!({})){{\n",
                        make_default_comparison(
                            format!("this.{}", screaming_snake_to_camel(setting.0)),
                            &setting.1.dtype
                        )
                    );
                    struct_name += &format!(
                        "javaOutStr += `${{devname}}Settings.set{}(${{this.{}}});\n`;\n",
                        screaming_snake_to_camel(setting.0),
                        screaming_snake_to_camel(setting.0)
                    );
                    struct_name += "}\n";
                }
            }
        }
    }

    struct_name += "return javaOutStr;\n";
    struct_name += "}\n";

    //--------C++ CODEGEN--------
    struct_name += "generate_cpp_codegen(devname: String): String {\n";
    struct_name += "let cppOutStr = `${devname}.resetFactoryDefaults();\\n`\n";
    struct_name += &format!(
        "cppOutStr += `{}.Settings ${{devname}}Settings = {}.Settings{{}};\\n`\n",
        dev.name, dev.name
    );

    for setting in dev.settings.iter() {
        if setting.1.vdep_setting && setting.1.vendordep {
            match &setting.1.dtype {
                DType::None => continue,
                DType::Pad { width } => continue,
                _ => {
                    struct_name += &format!(
                        "if (!({})){{\n",
                        make_default_comparison(
                            format!("this.{}", screaming_snake_to_camel(setting.0)),
                            &setting.1.dtype
                        )
                    );
                    struct_name += &format!(
                        "cppOutStr += `${{devname}}Settings.Set{}(${{this.{}}});`;\n",
                        screaming_snake_to_camel(setting.0),
                        screaming_snake_to_camel(setting.0)
                    );
                    struct_name += "}\n";
                }
            }
        }
    }

    struct_name += "return cppOutStr;\n";
    struct_name += "}\n";
    struct_name += "}\n\n";

    return struct_name;
}

fn generate_classes(dev: &Device) -> String {
    let mut returnstr = format!("");

    for class in dev.structs.iter() {
        let mut tmp_class = format!("export class {} {{\n", screaming_snake_to_camel(class.0));
        for item in class.1.signals.iter() {
            match item.dtype {
                DType::None => continue,
                DType::Pad { width } => continue,
                _ => {
                    tmp_class += &format!(
                        "{}: {} = {}\n",
                        item.name,
                        type_from_dtype(&item.dtype),
                        make_default(&item.dtype)
                    );
                }
            }
        }
        tmp_class += "}\n\n";
        returnstr += &tmp_class;
    }

    return returnstr;
}

fn generate_enums(dev: &Device) -> String {
    let mut returnstr = format!("");

    for enum_meta in dev.enums.iter() {
        returnstr += &format!("export enum {} {{\n", screaming_snake_to_camel(enum_meta.0));
        for item in enum_meta.1.values.iter() {
            returnstr += &format!(
                "{} = \"{}\",\n",
                item.1.name,
                screaming_snake_to_camel(&item.1.name)
            );
        }
        returnstr += "}\n\n";
    }

    return returnstr;
}

fn generate_bitset(dev: &Device) -> String {
    let mut returnstr = format!("");

    for bitset_meta in dev.bitsets.iter() {
        returnstr += &format!(
            "export class {} {{\nvalue: number = 0;\n",
            screaming_snake_to_camel(bitset_meta.0)
        );
        returnstr += "constructor(value: number) { \n this.value = value; \n }\n";
        for item in bitset_meta.1.flags.iter() {
            returnstr += &format!("{}(): boolean {{\n", item.name);
            returnstr += &format!("return ((this.value >> {}) & 0x01) == 1;\n", item.bit_idx);
            returnstr += "}\n";

            returnstr += &format!("set_{}(val: boolean) {{\n", item.name);
            returnstr += "if (val) {\n";
            returnstr += &format!("this.value = this.value | (1 << {}); \n", item.bit_idx);
            returnstr += "}\n";

            returnstr += "else {\n";
            returnstr += &format!("let mask = ~(1 << {});\n", item.bit_idx);
            returnstr += "this.value = this.value & mask; \n";
            returnstr += "}\n";

            returnstr += "}\n\n";
        }
        returnstr += "}\n\n";
    }

    return returnstr;
}

fn type_from_dtype(dtype: &DType) -> String {
    match dtype {
        DType::None => "".to_owned(),
        DType::UInt { meta } => "number".to_owned(),
        DType::SInt { meta } => "number".to_owned(),
        DType::Buf { meta } => "number[]".to_owned(),
        DType::Float { meta } => "number".to_owned(),
        DType::Bitset { meta } => {
            format!("{}", screaming_snake_to_camel(&meta.name))
        }
        DType::Pad { width } => "".to_owned(),
        DType::Bool { default_value } => "boolean".to_owned(),
        DType::Enum { meta } => {
            format!("{}", screaming_snake_to_camel(&meta.name))
        }
        DType::Struct { meta } => {
            format!("{}", screaming_snake_to_camel(&meta.name))
        }
    }
}

fn make_default(dtype: &DType) -> String {
    match dtype {
        DType::None => "".to_owned(),
        DType::UInt { meta } => {
            format!("{};", meta.default_value)
        }
        DType::SInt { meta } => {
            format!("{};", meta.default_value)
        }
        DType::Buf { meta } => {
            let mut returnstr = format!("[{}", meta.default_value[0]);

            for i in 1..(meta.width / 8) {
                returnstr += &format!(",{}", meta.default_value[i]);
            }
            returnstr += &format!("]");
            return returnstr;
        }
        DType::Float { meta } => {
            let default = if meta.default_value.is_infinite() {
                "Infinity"
            } else {
                &format!("{}", meta.default_value)
            };
            format!("{};", default)
        }
        DType::Bitset { meta } => {
            format!(
                "new {}({});",
                screaming_snake_to_camel(&meta.name),
                meta.default_u64()
            )
        }
        DType::Pad { width } => "".to_owned(),
        DType::Bool { default_value } => {
            if *default_value {
                "true;".to_owned()
            } else {
                "false;".to_owned()
            }
        }
        DType::Enum { meta } => {
            let default_name = if meta.default_value.len() == 0 {
                &meta.values.iter().next().unwrap().1.name
            } else {
                &meta.default_value
            };
            format!("{}.{};", screaming_snake_to_camel(&meta.name), default_name)
        }
        DType::Struct { meta } => {
            format!("new {}();", screaming_snake_to_camel(&meta.name))
        }
    }
}

fn make_default_comparison(name: String, dtype: &DType) -> String {
    match dtype {
        DType::None => "".to_owned(),
        DType::UInt { meta } => {
            format!("{} === {}", name, meta.default_value)
        }
        DType::SInt { meta } => {
            format!("{} === {}", name, meta.default_value)
        }
        DType::Buf { meta } => {
            let mut outstr = format!("{}[0] === {}", name, meta.default_value[0]);
            for i in 1..(meta.width / 8) {
                outstr += &format!(" && {}[{}] === {}", name, i, meta.default_value[i]);
            }
            outstr
        }
        DType::Float { meta } => {
            let default = if meta.default_value.is_infinite() {
                "Infinity"
            } else {
                &format!("{}", meta.default_value)
            };
            format!("{} === {}", name, default)
        }
        DType::Bitset { meta } => {
            format!("{}.value === {}", name, meta.default_u64())
        }
        DType::Pad { width } => "".to_owned(),
        DType::Bool { default_value } => {
            if *default_value {
                format!("{}", name)
            } else {
                format!("!{}", name)
            }
        }
        DType::Enum { meta } => {
            let default_name = if meta.default_value.len() == 0 {
                &meta.values.iter().next().unwrap().1.name
            } else {
                &meta.default_value
            };
            format!(
                "{} === {}.{}",
                name,
                screaming_snake_to_camel(&meta.name),
                default_name
            )
        }
        DType::Struct { meta } => {
            let mut outstr = format!(
                "{}",
                make_default_comparison(
                    format!("{}.{}", name, meta.signals.get(0).unwrap().name),
                    &meta.signals.get(0).unwrap().dtype
                )
            );
            for signal in meta.signals.iter() {
                match signal.dtype {
                    DType::None => {}
                    DType::Pad { width } => {}
                    _ => {
                        outstr += &format!(
                            " && {}",
                            make_default_comparison(
                                format!("{}.{}", name, signal.name),
                                &signal.dtype
                            )
                        );
                    }
                }
            }
            outstr
        }
    }
}

fn capitalize(s: &str) -> String {
    let mut c = s.chars();
    match c.next() {
        None => String::new(),
        Some(f) => f.to_uppercase().collect::<String>() + c.as_str(),
    }
}

fn screaming_snake_to_camel(s: &str) -> String {
    s.split('_')
        .by_ref()
        .map(|v| capitalize(v.to_lowercase().as_str()))
        .collect::<String>()
}

fn tabify(input: &str) -> String {
    let mut result = String::new();
    let mut indent_level: i32 = 0;

    for line in input.lines() {
        let trimmed_line = line.trim();

        // Check if the line contains a closing brace '}' at the beginning
        if trimmed_line.starts_with('}') {
            indent_level = indent_level.saturating_sub(1);
        }

        // Append the current line with the appropriate number of tabs
        result.push_str(&"\t".repeat(indent_level.try_into().unwrap()));
        result.push_str(trimmed_line);
        result.push('\n');

        // Check if the line contains an opening brace '{' at the end
        if trimmed_line.ends_with('{') {
            indent_level += 1;
        }
    }

    result
}
