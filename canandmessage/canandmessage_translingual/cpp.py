import typing
import textwrap
from .canandmessage_parser import *
from .canandmessage_parser import utils
# TODO:
# publicity checking
# enums as proper Java enumers?
# bitset builders
# range based validation for uints, sints, floats, and enums *(kinda done)
# any sort of utype conversions or factors


TEMPLATE = """// Copyright (c) Redux Robotics and other contributors.
// This is open source and can be modified and shared under the 3-clause BSD license. 

#pragma once
#include <cinttypes>
#include <vector>
#include <cstring>
#include "redux/canand/CanandUtils.h"
#include "redux/canand/CanandAddress.h"

/**
 * {device} protocol-level definitions.
 * 
 * This file is autogenerated by canandmessage, <b>do not hand-edit!</b>
 */
namespace {namespace}::details {{
{body}
}}
"""

STRUCT_TEMPLATE = """struct {name} {{
  public:
{members}
    /**
     * Decodes a struct.
     * 
     * @param data intfield to decode
     * @return a decoded struct
     */
    static constexpr {name} decode(uint64_t data) {{
        return {name} {{
{decode}  
        }};
    }}

    /**
     * Encodes a struct.
     *
     * @return an encoded struct.
     */
    constexpr uint64_t encode() {{
        return (
{encode} 
        );
    }}

{extra}
}};
"""

MESSAGE_EXTRA_TEMPLATE = """
/** Minimum acceptable data length code for this message */
static const uint32_t DLC_MIN = {dlc_min};

/** Maximum acceptable data length code for this message */
static const uint32_t DLC_MAX = {dlc_max};

/**
 * Sends the message struct to a CanandAddress.
 * @param addr the address to send to
 * @return the return value of SendCANMessage
 */
inline bool send(redux::canand::CanandAddress& addr) {{
    uint64_t data = this->encode();
    return addr.SendCANMessage(msg::{kamel}, (uint8_t*) &data, {dlc_max});
}}
"""



def gen_setting_ctor(stg: Setting) -> str:
    return f"""/** 
 * Construct setting {stg.name} 
 * @param data the data to pack into a setting bitfield
 * @return 48-bit data field of settings in the wire format
 */
inline uint64_t construct{utils.screaming_snake_to_camel(stg.name)}({type_for_dtype(stg.dtype)} data) {{
    return {pack_for_dtype("data", stg.dtype, 0, prefix="")};
}}
"""

def gen_setting_extract(stg: Setting) -> str:
    return f"""/** 
 * Unpack setting {stg.name} from the wire format.
 * @param data the 48-bit data field to extract a setting struct from.
 * @return a setting struct
 */
inline {type_for_dtype(stg.dtype)} extract{utils.screaming_snake_to_camel( stg.name)}(uint64_t data) {{
    return {unpack_for_dtype(stg.dtype, 0)};
}}
"""


INDENT = "    "
NL = "\n"

def njoin(s: typing.List[str]) -> str:
    return "\n".join(s)

def doc_comment(s: str) -> str:
    return f"/**\n{NL.join(' * ' + l for l in s.splitlines())}\n */"

def indent4(s: str) -> str:
    return textwrap.indent(s, "    ")

def indent8(s: str) -> str:
    return textwrap.indent(s, "        ")

def utype_for_width(width: int) -> str:
    if width <= 8:
        return "uint8_t"
    if width <= 16:
        return "uint16_t"
    if width <= 32:
        return "uint32_t"
    else:
        return "uint64_t"

def type_for_dtype(dtype: DType) -> str:
    width = dtype.bit_length()
    match dtype.meta:
        case UIntMeta() | BufMeta() | EnumMeta() | BitsetMeta():
            return utype_for_width(width)
        case SIntMeta():
            return utype_for_width(width)[1:]
        case FloatMeta():
            if dtype.meta.width <= 32:
                return "float"
            else:
                return "double"
        case BoolMeta():
            return "bool"
        case PadMeta():
            return None
        case StructMeta():
            return "types::" + utils.screaming_snake_to_camel(dtype.meta.name)
        case _:
            return None

def unpack_for_dtype(dtype: DType, offset: int) -> str:
    width = dtype.bit_length()
    match dtype.meta:
        case UIntMeta() | BitsetMeta() | BufMeta() | EnumMeta():
            if width <= 8:
                return f"redux::canand::utils::extractU8(data, {width}, {offset})"
            if width <= 16:
                return f"redux::canand::utils::extractU16(data, {width}, {offset})"
            if width <= 32:
                return f"redux::canand::utils::extractU32(data, {width}, {offset})"
            else:
                return f"redux::canand::utils::extractU64(data, {width}, {offset})"
        case SIntMeta():
            if width <= 8:
                return f"redux::canand::utils::extractI8(data, {width}, {offset})"
            if width <= 16:
                return f"redux::canand::utils::extractI16(data, {width}, {offset})"
            if width <= 32:
                return f"redux::canand::utils::extractI32(data, {width}, {offset})"
            else:
                return f"redux::canand::utils::extractI64(data, {width}, {offset})"
        case FloatMeta():
            if width == 24:
                return f"redux::canand::utils::extractF24(data, {offset})"
            if width == 32:
                return f"redux::canand::utils::extractF32(data, {offset})"
            if width == 64:
                return f"redux::canand::utils::extractF64(data, {offset})"
            else:
                raise ValueError("wlkdajhf")
        case BoolMeta():
            return f"redux::canand::utils::extractBool(data, {offset})"
        case PadMeta():
            return None
        case StructMeta():
            return "types::" + utils.screaming_snake_to_camel(dtype.meta.name) + f"::decode(data >> {offset})"
        case _:
            return None

def pack_for_dtype(name: str, dtype: DType, offset: int, prefix="this->") -> str:
    width = dtype.bit_length()
    match dtype.meta:
        case UIntMeta() | BitsetMeta() | BufMeta() | EnumMeta():
            return f"redux::canand::utils::packUInt({prefix}{name}, {width}, {offset})"
        case SIntMeta():
            return f"redux::canand::utils::packInt({prefix}{name}, {width}, {offset})"
        case FloatMeta():
            if width == 24:
                return f"redux::canand::utils::packF24({prefix}{name}, {offset})"
            if width == 32:
                return f"redux::canand::utils::packF32({prefix}{name}, {offset})"
            if width == 64:
                return f"redux::canand::utils::packF64({prefix}{name}, {offset})"
            else:
                raise ValueError("wlkdajhf")
        case BoolMeta():
            return f"redux::canand::utils::packBool({prefix}{name}, {offset})"
        case PadMeta():
            return None
        case StructMeta():
            return f"({prefix}{name}.encode() << {offset})"
        case _:
            return None

def gen_struct(name: str, signals: typing.List[Signal], extra=""):

    members = indent4("\n".join([
        f"/** {sig.comment} */\n"
        f"{type_for_dtype(sig.dtype)} {sig.name};\n"
        for sig in signals if not sig.dtype.is_pad()
    ]))

    extracts = []
    packs = ["0"]
    offset = 0
    for sig in signals:
        if sig.dtype.is_pad():
            offset += sig.dtype.bit_length()
            continue
    
        extracts.append(f".{sig.name} = {unpack_for_dtype(sig.dtype, offset)},")
        packs.append(pack_for_dtype(sig.name, sig.dtype, offset))
        offset += sig.dtype.bit_length()
    
    decode = textwrap.indent(njoin(extracts), INDENT * 3)
    encode = textwrap.indent(" |\n".join(packs), INDENT * 3)

    return STRUCT_TEMPLATE.format(
        name=name,
        members=members,
        extra=textwrap.indent(extra, INDENT),
        decode=decode,
        encode=encode
    )

def gen_bitset(meta: BitsetMeta) -> str:
    flags = []
    #getset = []
    utype = utype_for_width(meta.width)
    for flag in meta.flags:
        flags.append(f"/** {flag.comment} */")
        flags.append(f"{utils.screaming_snake_to_kamel(flag.name)} = 1 << {flag.bit_idx},\n")


    name = utils.screaming_snake_to_camel(meta.name)
    flags = indent8(njoin(flags))

    return f"""/** {name} bitset definition */
class {name} {{
  public:
    enum : {utype} {{
{flags}
    }};
}};
"""

def gen_enum(meta: EnumMeta) -> str:
    variants = []
    #getset = []
    utype = utype_for_width(meta.width)
    for idx, ent in meta.values.items():
        variants.append(f"/** {ent.comment} */")
        variants.append(f"{utils.screaming_snake_to_kamel(ent.name)} = 0x{idx:x},\n")
    
    return f"""/** {meta.name} enum definition */
class {utils.screaming_snake_to_camel(meta.name)} {{
  public:
    enum : {utype} {{
{indent8(njoin(variants))}
    }};
}};
"""

def gen_stg(dev: Device) -> str:
    indexes = []
    struct_defs = []
    vdep_stg = []

    for name, stg in dev.settings.items():
        if stg.vendordep:
            indexes.append(f"    /** {stg.comment} */")
            indexes.append(f"    {utils.screaming_snake_to_kamel(name)} = 0x{stg.id:x},\n")
            struct_defs.append(gen_setting_ctor(stg))
            struct_defs.append(gen_setting_extract(stg))
            if stg.vdep_setting:
                vdep_stg.append(utils.screaming_snake_to_kamel(name) + ",")



    return f"""
/** Settings. */
namespace setting {{
    enum : uint8_t {{
{indent4(njoin(indexes))}
    }};
{indent4(njoin(struct_defs))}

    /**
     * Settings that are required for the vdep to flag all values as received.
     */
    const std::vector<uint8_t> VDEP_SETTINGS = {{
{indent8(njoin(vdep_stg))}
    }};

}}"""


def gen_msg(dev: Device) -> str:

    indexes = []
    struct_defs = []
    for name, msg in dev.messages.items():
        if msg.is_public:
            indexes.append(f"    /** {msg.comment} */")
            indexes.append(f"    {utils.screaming_snake_to_kamel(name)} = 0x{msg.id:x},\n")
            struct_defs.append(f"/** {msg.comment} struct */")
            struct_defs.append(gen_struct(utils.screaming_snake_to_camel(name), msg.signals, extra=MESSAGE_EXTRA_TEMPLATE.format(
                kamel = utils.screaming_snake_to_kamel(name),
                dlc_min = msg.min_length,
                dlc_max = msg.max_length,
            )))


    return f"""
/** Messages. */
namespace msg {{
    enum : uint8_t {{
{indent4(njoin(indexes))}
    }};
{indent4(njoin(struct_defs))}
}}"""

def gen_types(dev: Device) -> str:
    struct_defs = []
    bitsets = []
    for name, struct_def in dev.structs.items():
        struct_defs.append(f"/** {struct_def.name} definition */")
        struct_defs.append(gen_struct(utils.screaming_snake_to_camel(name), struct_def.signals))
    
    bitsets = [gen_bitset(bitset_def) for bitset_def in dev.bitsets.values()]
    enums = [gen_enum(enum_def) for enum_def in dev.enums.values() if enum_def.is_public and enum_def.name != "SETTING"]
    return f"""
/** Types. */
namespace types {{
{indent4(njoin(bitsets))}
{indent4(njoin(enums))}
{indent4(njoin(struct_defs))}
}}"""


def gen_details(dev: Device) -> str:
    body = njoin([
        gen_types(dev),
        gen_msg(dev),
        gen_stg(dev)
    ])

    return TEMPLATE.format(
        device=dev.name,
        namespace=dev.cpp_namespace,
        body=indent4(body)
    )


if __name__ == "__main__":
    import sys
    import pathlib
    if len(sys.argv) < 3:
        print("usage", sys.argv[0], "[tomlfile] [reduxlib root]")

    in_path = pathlib.Path(sys.argv[1])
    reduxlib_path = pathlib.Path(sys.argv[2])

    dev: Device = parse_spec_to_device(in_path)
    out_path = reduxlib_path/f"src/main/native/include/{dev.cpp_namespace.replace('::', '/')}/{dev.name}Details.h"

    with open(out_path, "w") as f:
        f.write(gen_details(dev))