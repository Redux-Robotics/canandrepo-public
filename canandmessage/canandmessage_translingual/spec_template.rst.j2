..
    AUTOGENERATED FILE VIA canandmessage-- DO NOT EDIT THIS FILE MANUALLY!!!! (go edit canandmessage instead and regenerate)

{{ header(dev.name, "^") }}
{# {{ info['tagline'] }} #}
Message/wire format spec, version 2024-offseason.

The device spec for Redux products will not change in a backwards-incompatible fashion in-season, 
from the first official release for a given year until after the FIRST Championship.

{% if dev.name != "CanandDevice" %}
General properties
==================

{{ render_meta_table(dev) }}
The DBC files assumes a device id of 0.
For more information on the CAN device type, see :doc:`CanandDevice`
{% else %}

Summary of the CAN address scheme and packet format
===================================================
Redux CAN devices conform to the 29-bit FRC CAN message address scheme, with a very specific 
rearrangement of the API identifier/class field.

A full CAN arbitration id that actually gets put on the bus can be broken down into four components:

#. A 5 bit device type (devType) that is product specific (the Canandmag is 7 for "gear tooth sensor")
#. an 8-bit manufacturer code unique to each vendor (the Redux code is 14 in decimal or 0xE)
#. 10 bits of API identifier
#. a 6-bit device number (devId) that is user-configurable so you can have multiple of a device on a bus 
   -- this is what the "CAN ID" in robot code and vendor tuners usually refer to.

`The WPILib docs <https://docs.wpilib.org/en/stable/docs/software/can-devices/can-addressing.html>`_ elaborates on this in a bit more detail. 
Of note is that it breaks down the 10-bit API identifier into a 6-bit API class and 4-bit API index. 

Redux products break it down into a 2 bit API page (currently always 0) and an 8 bit API index (apiIndex).

The breakdown can be seen in the diagram provided below for a Party Mode packet sent to Canandmag device 4:

.. figure:: images/can-id-example.png
    :alt: CAN ID Breakdown Example (devid=0x7, vendor=0xe, prodid=0x0, apiIndex=0x7, devid=0x4)

    Based on diagram from: `WPILib Docs <https://docs.wpilib.org/en/stable/docs/software/can-devices/can-addressing.html>`_

Summary of the settings scheme
==============================
Redux CAN device have a series of settings that are up to 6 bytes in length, that are managed using the 
:ref:`set setting<cananddevice_msg_set_setting>`, :ref:`setting command<cananddevice_msg_setting_command>` and :ref:`report setting<cananddevice_msg_report_setting>` messages. 
Exact format and functionality of each setting field is generally device dependent.

Sending a :ref:`set setting<cananddevice_msg_set_setting>` packet, will trigger a :ref:`report setting<cananddevice_msg_report_setting>` message as a reply to 
confirm the transaction and success or failure.
The :ref:`setting command<cananddevice_msg_setting_command>` packet can be used to either report settings, reset to default settings, or perform other 
device-specific actions.

{% endif %}

All value fields are default unsigned little-endian unless otherwise specified.

This document uses the following conventions for notating field types:

==============  ==========================================================
Type            Description
==============  ==========================================================
bool            Single-bit boolean
float:24        IEEE 754 single-precision float with the least 
                significant 8 bits of mantissa stripped to fit in 3 bytes
float:32        IEEE 754 single-precision (32-bit) float
float:64        IEEE 754 double-precision (64-bit) float
uintN_t         Unsigned integer of bit width N
intN_t          Signed integer of bit width N
padN_t          N bits of padding bits that should be left zero.
uint8_t[N]      N bytes of a byte array
==============  ==========================================================

Additionally, when literals are specified for default values,

* ``true`` and ``false`` are defined as bit values 1 and 0 respectively
* for a byte array specified as ``{0x1, 0x2, 0x3, 0x4}`` the first (index zero) byte is 0x1 and the last is 0x4.

Messages
========

These are the definitions of messages sent over CAN, USB, or other encapsulation mechanisms.

**Message summary:**
{{ render_msg_summary_table(dev) }}

{% for name, msg in msg_to_render -%}
.. _{{dev_name}}_msg_{{ name|lower }}:

{{header(name, "-") -}}
{{ info["msg_" + name|lower] }}

**Properties**
{{ render_msg_table(msg, dev) }}

**Signals**
{{ render_msg_signal_table(msg.signals)}}
{% endfor %}


Settings
========


.. _{{dev_name}}_type_setting_data:

Settings hold and manipulate the configuration of the device.

Most settings are saved to non-volatile flash, are saved on device reboot, are considered both readable and writable, and 
will be reset to a default value when a :ref:`reset to factory default<{{dev_name}}_enum_setting_command>` setting command is issued.

Some settings are read-only as they contain device or firmare specific infomation such as serial number or firmware version.

Other settings may be write-only as they command the device to do something specific; e.g. update an offset.
In practice, settings get used whenever an infrequent (non-periodic) call-response architecture makes sense spec-wise.

Each setting is associated with an 8-bit unsigned setting index byte. Setting data is encoded as 48-bit (6 byte) fields.
Both setting index and encoded setting data are sent in :ref:`set setting<{{dev_name}}_msg_set_setting>` and :ref:`report_setting<{{dev_name}}_msg_report_setting>` messages,
whereas the :ref:`fetch setting value<{{dev_name}}_enum_setting_command>` setting command only requires an index.

If a type associated with a setting is less than 48 bits wide (e.g. a float32), the rest of the data field during encode/decode can be assumed to 
be padding and left as zero.

.. _{{dev_name}}_enum_setting:

**Setting summary:**

{{ render_stg_summary_table(dev) }}


{% for name, stg in setting_to_render %}
.. _{{dev_name}}_setting_{{ name|lower }}:

{{header(name, "-") -}}
{{ info["setting_" + name|lower] }}
{{ render_setting_table(dev, stg) -}}
{% endfor %}


{#
{% if setting_cmd_to_render %}
Setting commands
================

{{ render_stgcmd_summary_table(dev) }}

{% for name, stg_cmd in setting_cmd_to_render -%}
.. _stgcmd_{{ name|lower }}:

{{header(name, "-")}}
{{info['settingcmd'][name]}}
{{ render_setting_cmd_table(stg_cmd) }}
{% endfor %}
{% endif %}
#}

Types
=====

Data types associated with messages and/or settings.

{% for name, type in type_to_render %}
.. _{{dev_name}}_type_{{ name|lower }}:

{{header(name, "-")}}
{{ type.comment }}
{{ render_type(name, type, dev) -}}
{% endfor %}

Enums
=====
Enums associated with messages and/or settings. 
The backing type is always an unsigned int of some specified width.

{% for name, enum in enum_to_render %}

.. _{{dev_name}}_enum_{{ name|lower }}:

{{header(name, "-")}}
{% if name == "SETTING_COMMAND" -%}
These are setting commands issued via the :ref:`setting command<{{dev_name}}_msg_setting_command>` message.

The fetch setting command and reset factory settings command are common to all Redux devices.
{% else %}
{{ enum.comment -}}
{% endif %}
{{ render_enum(enum) -}}
{% endfor %}

{#
{% if dev.faults %}
Faults
======

These faults are reported in the active and sticky bitfields in the STATUS_ frame. All faults will affect the active and sticky fields --
that is, an active fault will also set its corresponding sticky index to true, and the sticky fault will stay true even after the fault
is no longer active until cleared.

{% for name, fault in dev.faults.items() %}
{{header(name, "-")}}
**Bit index: {{fault.index}}**

{{fault.vdoc}}
{% endfor %}
{% endif %}
#}