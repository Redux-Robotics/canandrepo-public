// Copyright (c) Bagholders of Redux Robotics and other contributors.
// This is open source and can be modified and shared under the Mozilla Public License v2.0. 

package com.reduxrobotics.sensors.canandgyro;

import java.util.HashMap;
import java.util.Map;

/**
 * Canandgyro device constants. 
 * 
 * This file is autogenerated by canandmessage, &lt;b&gt;do not hand-edit!&lt;/b&gt;
 */
public class CanandgyroDetails {
    private CanandgyroDetails() {}

    /**
     * Messages.
     */
    public static class Msg {
        private Msg() {}

        /**
         * Yaw angle frame
         */
        public static final int kYawOutput             = 0x1f;

        /**
         * Angular position quaternion frame
         */
        public static final int kAngularPositionOutput = 0x1e;

        /**
         * Angular velocity frame
         */
        public static final int kAngularVelocityOutput = 0x1d;

        /**
         * Acceleration frame
         */
        public static final int kAccelerationOutput    = 0x1c;

        /**
         * Trigger Calibration
         */
        public static final int kCalibrate             = 0x1b;

        /**
         * Calibration Status
         */
        public static final int kCalibrationStatus     = 0x1a;

        /**
         * Device enumerate response
         */
        public static final int kEnumerate             = 0xb;

        /**
         * Party mode
         */
        public static final int kPartyMode             = 0x7;

        /**
         * Status frame
         */
        public static final int kStatus                = 0x6;

        /**
         * Clear device sticky faults
         */
        public static final int kClearStickyFaults     = 0x5;

        /**
         * setting value report from device
         */
        public static final int kReportSetting         = 0x4;

        /**
         * update setting on device
         */
        public static final int kSetSetting            = 0x3;

        /**
         * setting control command
         */
        public static final int kSettingCommand        = 0x2;

        /**
         * Extracts Yaw angle (f32 between [-pi..pi) radians) from YawOutput_Yaw.
         * 
         * @param field data bitfield
         * @return yaw as a float:32
         */
        public static float extractYawOutput_Yaw_Yaw(long field) {
            return Float.intBitsToFloat(((int) field));
        }

        /**
         * Extracts Wraparound counter from YawOutput_Yaw.
         * 
         * @param field data bitfield
         * @return wraparound as a sint:16
         */
        public static int extractYawOutput_Yaw_Wraparound(long field) {
            return ((((int) (field >> 32)) & 0xffff) << 16) >> 16;
        }

        /**
         * Extracts Quaternion w term from AngularPositionOutput.
         * 
         * @param field data bitfield
         * @return w as a sint:16
         */
        public static int extractAngularPositionOutput_W(long field) {
            return ((((int) field) & 0xffff) << 16) >> 16;
        }

        /**
         * Extracts Quaternion x term from AngularPositionOutput.
         * 
         * @param field data bitfield
         * @return x as a sint:16
         */
        public static int extractAngularPositionOutput_X(long field) {
            return ((((int) (field >> 16)) & 0xffff) << 16) >> 16;
        }

        /**
         * Extracts Quaternion y term from AngularPositionOutput.
         * 
         * @param field data bitfield
         * @return y as a sint:16
         */
        public static int extractAngularPositionOutput_Y(long field) {
            return ((((int) (field >> 32)) & 0xffff) << 16) >> 16;
        }

        /**
         * Extracts Quaternion z term from AngularPositionOutput.
         * 
         * @param field data bitfield
         * @return z as a sint:16
         */
        public static int extractAngularPositionOutput_Z(long field) {
            return ((((int) (field >> 48)) & 0xffff) << 16) >> 16;
        }

        /**
         * Extracts Yaw velocity from AngularVelocityOutput.
         * 
         * @param field data bitfield
         * @return yaw as a sint:16
         */
        public static int extractAngularVelocityOutput_Yaw(long field) {
            return ((((int) field) & 0xffff) << 16) >> 16;
        }

        /**
         * Extracts Pitch velocity from AngularVelocityOutput.
         * 
         * @param field data bitfield
         * @return pitch as a sint:16
         */
        public static int extractAngularVelocityOutput_Pitch(long field) {
            return ((((int) (field >> 16)) & 0xffff) << 16) >> 16;
        }

        /**
         * Extracts Roll velocity from AngularVelocityOutput.
         * 
         * @param field data bitfield
         * @return roll as a sint:16
         */
        public static int extractAngularVelocityOutput_Roll(long field) {
            return ((((int) (field >> 32)) & 0xffff) << 16) >> 16;
        }

        /**
         * Extracts Z-axis acceleration from AccelerationOutput.
         * 
         * @param field data bitfield
         * @return z as a sint:16
         */
        public static int extractAccelerationOutput_Z(long field) {
            return ((((int) field) & 0xffff) << 16) >> 16;
        }

        /**
         * Extracts Y-axis acceleration from AccelerationOutput.
         * 
         * @param field data bitfield
         * @return y as a sint:16
         */
        public static int extractAccelerationOutput_Y(long field) {
            return ((((int) (field >> 16)) & 0xffff) << 16) >> 16;
        }

        /**
         * Extracts X-axis acceleration from AccelerationOutput.
         * 
         * @param field data bitfield
         * @return x as a sint:16
         */
        public static int extractAccelerationOutput_X(long field) {
            return ((((int) (field >> 32)) & 0xffff) << 16) >> 16;
        }

        /**
         * Extracts Calibration type from Calibrate.
         * 
         * @param field data bitfield
         * @return calibration_type as a enum:CALIBRATION_TYPE
         */
        public static int extractCalibrate_CalibrationType(long field) {
            return ((int) field) & 0xff;
        }

        /**
         * Extracts Device-unique serial number from Enumerate.
         * 
         * @param field data bitfield
         * @return serial as a buf:48
         */
        public static long extractEnumerate_Serial(long field) {
            return field & 0xffffffffffffL;
        }

        /**
         * Extracts Device is in bootloader. from Enumerate.
         * 
         * @param field data bitfield
         * @return is_bootloader as a bool
         */
        public static boolean extractEnumerate_IsBootloader(long field) {
            return ((field >> 48) & 1) > 0;
        }

        /**
         * Extracts Party level. 0 disables the strobe, whereas 1 enables it. from PartyMode.
         * 
         * @param field data bitfield
         * @return party_level as a uint:8
         */
        public static int extractPartyMode_PartyLevel(long field) {
            return ((int) field) & 0xff;
        }

        /**
         * Extracts 8-bit active faults bitfield from Status.
         * 
         * @param field data bitfield
         * @return faults as a bitset:8
         */
        public static int extractStatus_Faults(long field) {
            return ((int) field) & 0xff;
        }

        /**
         * Extracts 8-bit sticky faults bitfield from Status.
         * 
         * @param field data bitfield
         * @return sticky_faults as a bitset:8
         */
        public static int extractStatus_StickyFaults(long field) {
            return ((int) (field >> 8)) & 0xff;
        }

        /**
         * Extracts 16-bit signed temperature byte in 1/256ths of a Celsius from Status.
         * 
         * @param field data bitfield
         * @return temperature as a sint:16
         */
        public static int extractStatus_Temperature(long field) {
            return ((((int) (field >> 16)) & 0xffff) << 16) >> 16;
        }

        /**
         * Extracts Setting index to write to from ReportSetting.
         * 
         * @param field data bitfield
         * @return address as a enum:SETTING
         */
        public static int extractReportSetting_Address(long field) {
            return ((int) field) & 0xff;
        }

        /**
         * Extracts 6-byte setting value from ReportSetting.
         * 
         * @param field data bitfield
         * @return value as a buf:48
         */
        public static long extractReportSetting_Value(long field) {
            return (field >> 8) & 0xffffffffffffL;
        }

        /**
         * Extracts Setting receive status from ReportSetting.
         * 
         * @param field data bitfield
         * @return flags as a bitset:8
         */
        public static int extractReportSetting_Flags(long field) {
            return ((int) (field >> 56)) & 0xff;
        }

        /**
         * Extracts Setting index to write to from SetSetting.
         * 
         * @param field data bitfield
         * @return address as a enum:SETTING
         */
        public static int extractSetSetting_Address(long field) {
            return ((int) field) & 0xff;
        }

        /**
         * Extracts 6-byte setting value from SetSetting.
         * 
         * @param field data bitfield
         * @return value as a buf:48
         */
        public static long extractSetSetting_Value(long field) {
            return (field >> 8) & 0xffffffffffffL;
        }

        /**
         * Extracts Whether the setting should be set ephemeral from SetSetting_Flags.
         * 
         * @param field data bitfield
         * @return ephemeral as a bool
         */
        public static boolean extractSetSetting_Flags_Ephemeral(long field) {
            return ((field >> 56) & 1) > 0;
        }

        /**
         * Extracts Whether the setting should be held until the next synch barrier from SetSetting_Flags.
         * 
         * @param field data bitfield
         * @return synch_hold as a bool
         */
        public static boolean extractSetSetting_Flags_SynchHold(long field) {
            return ((field >> 57) & 1) > 0;
        }

        /**
         * Extracts Synch message count from SetSetting_Flags.
         * 
         * @param field data bitfield
         * @return synch_msg_count as a uint:4
         */
        public static int extractSetSetting_Flags_SynchMsgCount(long field) {
            return ((int) (field >> 60)) & 0xf;
        }

        /**
         * Extracts Setting command index from SettingCommand.
         * 
         * @param field data bitfield
         * @return control_flag as a enum:SETTING_COMMAND
         */
        public static int extractSettingCommand_ControlFlag(long field) {
            return ((int) field) & 0xff;
        }

        /**
         * Extracts setting index to fetch from SettingCommand.
         * 
         * @param field data bitfield
         * @return setting_index as a enum:SETTING
         */
        public static int extractSettingCommand_SettingIndex(long field) {
            return ((int) (field >> 8)) & 0xff;
        }

        /**
         * Constructs a YAW_OUTPUT message.
         * 
         * @param yawYaw Yaw angle (f32 between [-pi..pi) radians) (float:32)
         * @param yawWraparound Wraparound counter (sint:16)
         * @return message data as long
         */
        public static long constructYawOutput(float yawYaw, int yawWraparound) {
            return ((long) Float.floatToIntBits(yawYaw) & 0xffffffffL) | 
                (((long) yawWraparound) << 32);
        }

        /**
         * Constructs a ANGULAR_POSITION_OUTPUT message.
         * 
         * @param w Quaternion w term (sint:16)
         * @param x Quaternion x term (sint:16)
         * @param y Quaternion y term (sint:16)
         * @param z Quaternion z term (sint:16)
         * @return message data as long
         */
        public static long constructAngularPositionOutput(int w, int x, int y, int z) {
            return ((long) w) | 
                (((long) x) << 16) | 
                (((long) y) << 32) | 
                (((long) z) << 48);
        }

        /**
         * Constructs a ANGULAR_VELOCITY_OUTPUT message.
         * 
         * @param yaw Yaw velocity (sint:16)
         * @param pitch Pitch velocity (sint:16)
         * @param roll Roll velocity (sint:16)
         * @return message data as long
         */
        public static long constructAngularVelocityOutput(int yaw, int pitch, int roll) {
            return ((long) yaw) | 
                (((long) pitch) << 16) | 
                (((long) roll) << 32);
        }

        /**
         * Constructs a ACCELERATION_OUTPUT message.
         * 
         * @param z Z-axis acceleration (sint:16)
         * @param y Y-axis acceleration (sint:16)
         * @param x X-axis acceleration (sint:16)
         * @return message data as long
         */
        public static long constructAccelerationOutput(int z, int y, int x) {
            return ((long) z) | 
                (((long) y) << 16) | 
                (((long) x) << 32);
        }

        /**
         * Constructs a CALIBRATE message.
         * 
         * @param calibrationType Calibration type (enum:CALIBRATION_TYPE)
         * @return message data as long
         */
        public static long constructCalibrate(int calibrationType) {
            return ((long) calibrationType);
        }

        /**
         * Constructs a CALIBRATION_STATUS message.
         * 
         * 
         * @return message data as long
         */
        public static long constructCalibrationStatus() {
            return 0;
        }

        /**
         * Constructs a ENUMERATE message.
         * 
         * @param serial Device-unique serial number (buf:48)
         * @param isBootloader Device is in bootloader. (bool)
         * @return message data as long
         */
        public static long constructEnumerate(long serial, boolean isBootloader) {
            return (serial & 0xffffffffffffL) | 
                ((isBootloader ? 1L : 0L) << 48);
        }

        /**
         * Constructs a PARTY_MODE message.
         * 
         * @param partyLevel Party level. 0 disables the strobe, whereas 1 enables it. (uint:8)
         * @return message data as long
         */
        public static long constructPartyMode(int partyLevel) {
            return ((long) partyLevel);
        }

        /**
         * Constructs a STATUS message.
         * 
         * @param faults 8-bit active faults bitfield (bitset:8)
         * @param stickyFaults 8-bit sticky faults bitfield (bitset:8)
         * @param temperature 16-bit signed temperature byte in 1/256ths of a Celsius (sint:16)
         * @return message data as long
         */
        public static long constructStatus(int faults, int stickyFaults, int temperature) {
            return ((long) faults) | 
                (((long) stickyFaults) << 8) | 
                (((long) temperature) << 16);
        }

        /**
         * Constructs a CLEAR_STICKY_FAULTS message.
         * 
         * 
         * @return message data as long
         */
        public static long constructClearStickyFaults() {
            return 0;
        }

        /**
         * Constructs a REPORT_SETTING message.
         * 
         * @param address Setting index to write to (enum:SETTING)
         * @param value 6-byte setting value (buf:48)
         * @param flags Setting receive status (bitset:8)
         * @return message data as long
         */
        public static long constructReportSetting(int address, long value, int flags) {
            return ((long) address) | 
                ((value & 0xffffffffffffL) << 8) | 
                (((long) flags) << 56);
        }

        /**
         * Constructs a SET_SETTING message.
         * 
         * @param address Setting index to write to (enum:SETTING)
         * @param value 6-byte setting value (buf:48)
         * @param flagsEphemeral Whether the setting should be set ephemeral (bool)
         * @param flagsSynchHold Whether the setting should be held until the next synch barrier (bool)
         * @param flagsSynchMsgCount Synch message count (uint:4)
         * @return message data as long
         */
        public static long constructSetSetting(int address, long value, boolean flagsEphemeral, boolean flagsSynchHold, int flagsSynchMsgCount) {
            return ((long) address) | 
                ((value & 0xffffffffffffL) << 8) | 
                ((flagsEphemeral ? 1L : 0L) << 56) | 
                ((flagsSynchHold ? 1L : 0L) << 57) | 
                (((long) flagsSynchMsgCount) << 60);
        }

        /**
         * Constructs a SETTING_COMMAND message.
         * 
         * @param controlFlag Setting command index (enum:SETTING_COMMAND)
         * @param settingIndex setting index to fetch (enum:SETTING)
         * @return message data as long
         */
        public static long constructSettingCommand(int controlFlag, int settingIndex) {
            return ((long) controlFlag) | 
                (((long) settingIndex) << 8);
        }

        /** YAW_OUTPUT message length */
        public static final int kDlc_YawOutput = 6;

        /**
         * Check if YAW_OUTPUT message length is valid.
         * @param dlc length to check
         * @return true if valid
         */
        public static boolean checkDlcForYawOutput(int dlc) {
            return dlc == 6;
        }

        /** ANGULAR_POSITION_OUTPUT message length */
        public static final int kDlc_AngularPositionOutput = 8;

        /**
         * Check if ANGULAR_POSITION_OUTPUT message length is valid.
         * @param dlc length to check
         * @return true if valid
         */
        public static boolean checkDlcForAngularPositionOutput(int dlc) {
            return dlc == 8;
        }

        /** ANGULAR_VELOCITY_OUTPUT message length */
        public static final int kDlc_AngularVelocityOutput = 6;

        /**
         * Check if ANGULAR_VELOCITY_OUTPUT message length is valid.
         * @param dlc length to check
         * @return true if valid
         */
        public static boolean checkDlcForAngularVelocityOutput(int dlc) {
            return dlc == 6;
        }

        /** ACCELERATION_OUTPUT message length */
        public static final int kDlc_AccelerationOutput = 6;

        /**
         * Check if ACCELERATION_OUTPUT message length is valid.
         * @param dlc length to check
         * @return true if valid
         */
        public static boolean checkDlcForAccelerationOutput(int dlc) {
            return dlc == 6;
        }

        /** CALIBRATE message length */
        public static final int kDlc_Calibrate = 8;

        /**
         * Check if CALIBRATE message length is valid.
         * @param dlc length to check
         * @return true if valid
         */
        public static boolean checkDlcForCalibrate(int dlc) {
            return dlc == 8;
        }

        /** CALIBRATION_STATUS message length */
        public static final int kDlc_CalibrationStatus = 8;

        /**
         * Check if CALIBRATION_STATUS message length is valid.
         * @param dlc length to check
         * @return true if valid
         */
        public static boolean checkDlcForCalibrationStatus(int dlc) {
            return dlc == 8;
        }

        /** ENUMERATE message length */
        public static final int kDlc_Enumerate = 8;

        /**
         * Check if ENUMERATE message length is valid.
         * @param dlc length to check
         * @return true if valid
         */
        public static boolean checkDlcForEnumerate(int dlc) {
            return dlc == 8;
        }

        /** PARTY_MODE message min length */
        public static final int kDlcMin_PartyMode = 1;

        /** PARTY_MODE message max length */
        public static final int kDlcMax_PartyMode = 8;

        /**
         * Check if PARTY_MODE message length is valid.
         * @param dlc length to check
         * @return true if valid
         */
        public static boolean checkDlcForPartyMode(int dlc) {
            return dlc >= 1 && dlc <= 8;
        }

        /** STATUS message length */
        public static final int kDlc_Status = 8;

        /**
         * Check if STATUS message length is valid.
         * @param dlc length to check
         * @return true if valid
         */
        public static boolean checkDlcForStatus(int dlc) {
            return dlc == 8;
        }

        /** CLEAR_STICKY_FAULTS message min length */
        public static final int kDlcMin_ClearStickyFaults = 0;

        /** CLEAR_STICKY_FAULTS message max length */
        public static final int kDlcMax_ClearStickyFaults = 8;

        /**
         * Check if CLEAR_STICKY_FAULTS message length is valid.
         * @param dlc length to check
         * @return true if valid
         */
        public static boolean checkDlcForClearStickyFaults(int dlc) {
            return dlc >= 0 && dlc <= 8;
        }

        /** REPORT_SETTING message length */
        public static final int kDlc_ReportSetting = 8;

        /**
         * Check if REPORT_SETTING message length is valid.
         * @param dlc length to check
         * @return true if valid
         */
        public static boolean checkDlcForReportSetting(int dlc) {
            return dlc == 8;
        }

        /** SET_SETTING message length */
        public static final int kDlc_SetSetting = 8;

        /**
         * Check if SET_SETTING message length is valid.
         * @param dlc length to check
         * @return true if valid
         */
        public static boolean checkDlcForSetSetting(int dlc) {
            return dlc == 8;
        }

        /** SETTING_COMMAND message min length */
        public static final int kDlcMin_SettingCommand = 1;

        /** SETTING_COMMAND message max length */
        public static final int kDlcMax_SettingCommand = 8;

        /**
         * Check if SETTING_COMMAND message length is valid.
         * @param dlc length to check
         * @return true if valid
         */
        public static boolean checkDlcForSettingCommand(int dlc) {
            return dlc >= 1 && dlc <= 8;
        }
    }

    /**
     * Settings.
     */
    public static class Stg {
        private Stg() {}

        /**
         * Yaw angle frame period (ms)
         */
        public static final int kYawFramePeriod             = 0xff;

        /**
         * Angular position frame period (ms)
         */
        public static final int kAngularPositionFramePeriod = 0xfe;

        /**
         * Angular velocity frame period (ms)
         */
        public static final int kAngularVelocityFramePeriod = 0xfd;

        /**
         * Acceleration frame period (ms)
         */
        public static final int kAccelerationFramePeriod    = 0xfc;

        /**
         * Set yaw
         */
        public static final int kSetYaw                     = 0xfb;

        /**
         * Set (normed) quaternion assuming positive W
         */
        public static final int kSetPosePositiveW           = 0xfa;

        /**
         * Set (normed) quaternion assuming negative W
         */
        public static final int kSetPoseNegativeW           = 0xf9;

        /**
         * Device-specific type identifier
         */
        public static final int kDeviceType                 = 0x8;

        /**
         * Firmware version
         */
        public static final int kFirmwareVersion            = 0x6;

        /**
         * Serial number
         */
        public static final int kSerialNumber               = 0x5;

        /**
         * Status frame period (ms)
         */
        public static final int kStatusFramePeriod          = 0x4;

        /**
         * Extracts Yaw angle frame period (ms) from YawFramePeriod.
         * 
         * @param field data bitfield
         * @return YAW_FRAME_PERIOD as a uint:16
         */
        public static int extractYawFramePeriod(long field) {
            return ((int) field) & 0xffff;
        }

        /**
         * Extracts Angular position frame period (ms) from AngularPositionFramePeriod.
         * 
         * @param field data bitfield
         * @return ANGULAR_POSITION_FRAME_PERIOD as a uint:16
         */
        public static int extractAngularPositionFramePeriod(long field) {
            return ((int) field) & 0xffff;
        }

        /**
         * Extracts Angular velocity frame period (ms) from AngularVelocityFramePeriod.
         * 
         * @param field data bitfield
         * @return ANGULAR_VELOCITY_FRAME_PERIOD as a uint:16
         */
        public static int extractAngularVelocityFramePeriod(long field) {
            return ((int) field) & 0xffff;
        }

        /**
         * Extracts Acceleration frame period (ms) from AccelerationFramePeriod.
         * 
         * @param field data bitfield
         * @return ACCELERATION_FRAME_PERIOD as a uint:16
         */
        public static int extractAccelerationFramePeriod(long field) {
            return ((int) field) & 0xffff;
        }

        /**
         * Extracts Yaw angle (f32 between [-pi..pi) radians) from SetYaw.
         * 
         * @param field data bitfield
         * @return yaw as a float:32
         */
        public static float extractSetYaw_Yaw(long field) {
            return Float.intBitsToFloat(((int) field));
        }

        /**
         * Extracts Wraparound counter from SetYaw.
         * 
         * @param field data bitfield
         * @return wraparound as a sint:16
         */
        public static int extractSetYaw_Wraparound(long field) {
            return ((((int) (field >> 32)) & 0xffff) << 16) >> 16;
        }

        /**
         * Extracts Quaternion x term from SetPosePositiveW.
         * 
         * @param field data bitfield
         * @return x as a sint:16
         */
        public static int extractSetPosePositiveW_X(long field) {
            return ((((int) field) & 0xffff) << 16) >> 16;
        }

        /**
         * Extracts Quaternion y term from SetPosePositiveW.
         * 
         * @param field data bitfield
         * @return y as a sint:16
         */
        public static int extractSetPosePositiveW_Y(long field) {
            return ((((int) (field >> 16)) & 0xffff) << 16) >> 16;
        }

        /**
         * Extracts Quaternion z term from SetPosePositiveW.
         * 
         * @param field data bitfield
         * @return z as a sint:16
         */
        public static int extractSetPosePositiveW_Z(long field) {
            return ((((int) (field >> 32)) & 0xffff) << 16) >> 16;
        }

        /**
         * Extracts Quaternion x term from SetPoseNegativeW.
         * 
         * @param field data bitfield
         * @return x as a sint:16
         */
        public static int extractSetPoseNegativeW_X(long field) {
            return ((((int) field) & 0xffff) << 16) >> 16;
        }

        /**
         * Extracts Quaternion y term from SetPoseNegativeW.
         * 
         * @param field data bitfield
         * @return y as a sint:16
         */
        public static int extractSetPoseNegativeW_Y(long field) {
            return ((((int) (field >> 16)) & 0xffff) << 16) >> 16;
        }

        /**
         * Extracts Quaternion z term from SetPoseNegativeW.
         * 
         * @param field data bitfield
         * @return z as a sint:16
         */
        public static int extractSetPoseNegativeW_Z(long field) {
            return ((((int) (field >> 32)) & 0xffff) << 16) >> 16;
        }

        /**
         * Extracts Device-specific type identifier from DeviceType.
         * 
         * @param field data bitfield
         * @return DEVICE_TYPE as a uint:16
         */
        public static int extractDeviceType(long field) {
            return ((int) field) & 0xffff;
        }

        /**
         * Extracts Firmware version patch number from FirmwareVersion.
         * 
         * @param field data bitfield
         * @return firmware_patch as a uint:8
         */
        public static int extractFirmwareVersion_FirmwarePatch(long field) {
            return ((int) field) & 0xff;
        }

        /**
         * Extracts Firmware version minor number from FirmwareVersion.
         * 
         * @param field data bitfield
         * @return firmware_minor as a uint:8
         */
        public static int extractFirmwareVersion_FirmwareMinor(long field) {
            return ((int) (field >> 8)) & 0xff;
        }

        /**
         * Extracts Firmware version year from FirmwareVersion.
         * 
         * @param field data bitfield
         * @return firmware_year as a uint:16
         */
        public static int extractFirmwareVersion_FirmwareYear(long field) {
            return ((int) (field >> 16)) & 0xffff;
        }

        /**
         * Extracts Serial number from SerialNumber.
         * 
         * @param field data bitfield
         * @return SERIAL_NUMBER as a buf:48
         */
        public static long extractSerialNumber(long field) {
            return field & 0xffffffffffffL;
        }

        /**
         * Extracts Status frame period (ms) from StatusFramePeriod.
         * 
         * @param field data bitfield
         * @return STATUS_FRAME_PERIOD as a uint:16
         */
        public static int extractStatusFramePeriod(long field) {
            return ((int) field) & 0xffff;
        }

        /**
         * Constructs a YAW_FRAME_PERIOD setting.
         * 
         * @param yawFramePeriod Yaw angle frame period (ms) (uint:16)
         * @return message data as long
         */
        public static long constructYawFramePeriod(int yawFramePeriod) {
            if (yawFramePeriod < 0 || yawFramePeriod > 65535) { throw new IllegalArgumentException("yawFramePeriod must be between [0..=65535] inclusive, instead got " + yawFramePeriod); }
            return ((long) yawFramePeriod);
        }

        /**
         * Constructs a ANGULAR_POSITION_FRAME_PERIOD setting.
         * 
         * @param angularPositionFramePeriod Angular position frame period (ms) (uint:16)
         * @return message data as long
         */
        public static long constructAngularPositionFramePeriod(int angularPositionFramePeriod) {
            if (angularPositionFramePeriod < 0 || angularPositionFramePeriod > 65535) { throw new IllegalArgumentException("angularPositionFramePeriod must be between [0..=65535] inclusive, instead got " + angularPositionFramePeriod); }
            return ((long) angularPositionFramePeriod);
        }

        /**
         * Constructs a ANGULAR_VELOCITY_FRAME_PERIOD setting.
         * 
         * @param angularVelocityFramePeriod Angular velocity frame period (ms) (uint:16)
         * @return message data as long
         */
        public static long constructAngularVelocityFramePeriod(int angularVelocityFramePeriod) {
            if (angularVelocityFramePeriod < 0 || angularVelocityFramePeriod > 65535) { throw new IllegalArgumentException("angularVelocityFramePeriod must be between [0..=65535] inclusive, instead got " + angularVelocityFramePeriod); }
            return ((long) angularVelocityFramePeriod);
        }

        /**
         * Constructs a ACCELERATION_FRAME_PERIOD setting.
         * 
         * @param accelerationFramePeriod Acceleration frame period (ms) (uint:16)
         * @return message data as long
         */
        public static long constructAccelerationFramePeriod(int accelerationFramePeriod) {
            if (accelerationFramePeriod < 0 || accelerationFramePeriod > 65535) { throw new IllegalArgumentException("accelerationFramePeriod must be between [0..=65535] inclusive, instead got " + accelerationFramePeriod); }
            return ((long) accelerationFramePeriod);
        }

        /**
         * Constructs a SET_YAW setting.
         * 
         * @param yaw Yaw angle (f32 between [-pi..pi) radians) (float:32)
         * @param wraparound Wraparound counter (sint:16)
         * @return message data as long
         */
        public static long constructSetYaw(float yaw, int wraparound) {
            if (wraparound < -32768 || wraparound > 32767) { throw new IllegalArgumentException("wraparound must be between [-32768..=32767] inclusive, instead got " + wraparound); }
            return ((long) Float.floatToIntBits(yaw) & 0xffffffffL) | 
                (((long) wraparound) << 32);
        }

        /**
         * Constructs a SET_POSE_POSITIVE_W setting.
         * 
         * @param x Quaternion x term (sint:16)
         * @param y Quaternion y term (sint:16)
         * @param z Quaternion z term (sint:16)
         * @return message data as long
         */
        public static long constructSetPosePositiveW(int x, int y, int z) {
            if (x < -32767 || x > 32767) { throw new IllegalArgumentException("x must be between [-32767..=32767] inclusive, instead got " + x); }
            if (y < -32767 || y > 32767) { throw new IllegalArgumentException("y must be between [-32767..=32767] inclusive, instead got " + y); }
            if (z < -32767 || z > 32767) { throw new IllegalArgumentException("z must be between [-32767..=32767] inclusive, instead got " + z); }
            return ((long) x) | 
                (((long) y) << 16) | 
                (((long) z) << 32);
        }

        /**
         * Constructs a SET_POSE_NEGATIVE_W setting.
         * 
         * @param x Quaternion x term (sint:16)
         * @param y Quaternion y term (sint:16)
         * @param z Quaternion z term (sint:16)
         * @return message data as long
         */
        public static long constructSetPoseNegativeW(int x, int y, int z) {
            if (x < -32767 || x > 32767) { throw new IllegalArgumentException("x must be between [-32767..=32767] inclusive, instead got " + x); }
            if (y < -32767 || y > 32767) { throw new IllegalArgumentException("y must be between [-32767..=32767] inclusive, instead got " + y); }
            if (z < -32767 || z > 32767) { throw new IllegalArgumentException("z must be between [-32767..=32767] inclusive, instead got " + z); }
            return ((long) x) | 
                (((long) y) << 16) | 
                (((long) z) << 32);
        }

        /**
         * Constructs a DEVICE_TYPE setting.
         * 
         * @param deviceType Device-specific type identifier (uint:16)
         * @return message data as long
         */
        public static long constructDeviceType(int deviceType) {
            if (deviceType < 0 || deviceType > 65535) { throw new IllegalArgumentException("deviceType must be between [0..=65535] inclusive, instead got " + deviceType); }
            return ((long) deviceType);
        }

        /**
         * Constructs a FIRMWARE_VERSION setting.
         * 
         * @param firmwarePatch Firmware version patch number (uint:8)
         * @param firmwareMinor Firmware version minor number (uint:8)
         * @param firmwareYear Firmware version year (uint:16)
         * @return message data as long
         */
        public static long constructFirmwareVersion(int firmwarePatch, int firmwareMinor, int firmwareYear) {
            if (firmwarePatch < 0 || firmwarePatch > 255) { throw new IllegalArgumentException("firmwarePatch must be between [0..=255] inclusive, instead got " + firmwarePatch); }
            if (firmwareMinor < 0 || firmwareMinor > 255) { throw new IllegalArgumentException("firmwareMinor must be between [0..=255] inclusive, instead got " + firmwareMinor); }
            if (firmwareYear < 0 || firmwareYear > 65535) { throw new IllegalArgumentException("firmwareYear must be between [0..=65535] inclusive, instead got " + firmwareYear); }
            return ((long) firmwarePatch) | 
                (((long) firmwareMinor) << 8) | 
                (((long) firmwareYear) << 16);
        }

        /**
         * Constructs a SERIAL_NUMBER setting.
         * 
         * @param serialNumber Serial number (buf:48)
         * @return message data as long
         */
        public static long constructSerialNumber(long serialNumber) {
            if (serialNumber < 0L || serialNumber > 281474976710655L) { throw new IllegalArgumentException("serialNumber must be between [0..=281474976710655] inclusive, instead got " + serialNumber); }
            return (serialNumber & 0xffffffffffffL);
        }

        /**
         * Constructs a STATUS_FRAME_PERIOD setting.
         * 
         * @param statusFramePeriod Status frame period (ms) (uint:16)
         * @return message data as long
         */
        public static long constructStatusFramePeriod(int statusFramePeriod) {
            if (statusFramePeriod < 1 || statusFramePeriod > 16383) { throw new IllegalArgumentException("statusFramePeriod must be between [1..=16383] inclusive, instead got " + statusFramePeriod); }
            return ((long) statusFramePeriod);
        }

        /** List of settings to fetch for. */
        public static int settingsAddresses[] = {
            kStatusFramePeriod,
            kYawFramePeriod,
            kAngularPositionFramePeriod,
            kAngularVelocityFramePeriod,
            kAccelerationFramePeriod,
        };

        /** Creates a HashMap of writable default settings. 
         * @return default settings
         */
        public static Map<Integer, Long> defaultSettings() {
            Map<Integer, Long> stg = new HashMap<>();
            stg.put(kStatusFramePeriod, 0x64L);
            stg.put(kYawFramePeriod, 0xaL);
            stg.put(kAngularPositionFramePeriod, 0x14L);
            stg.put(kAngularVelocityFramePeriod, 0x64L);
            stg.put(kAccelerationFramePeriod, 0x64L);
            return stg;
        }

    }

    /**
     * Canandgyro enums.
     */
    public static class Enums {
        private Enums() {}

        /**
         * enum Canandgyro::CALIBRATION_TYPE.
         */
        public static class CalibrationType {
            private CalibrationType() {}

            /**
             * Normal calibration routine
             */
            public static final int kNormal   = 0x0;

            /**
             * Save ZRO at calibration complete
             */
            public static final int kSaveZro  = 0x1;

            /**
             * Temperature calibrate slot 0
             */
            public static final int kTempCal0 = 0x2;

            /**
             * Temperature calibrate slot 1
             */
            public static final int kTempCal1 = 0x3;
        }

        /**
         * enum Canandgyro::SETTING_COMMAND.
         */
        public static class SettingCommand {
            private SettingCommand() {}

            /**
             * Fetch all settings from device via a series of :ref:`report setting&lt;msg_report_setting&gt;` messages of all indexes
             */
            public static final int kFetchSettings       = 0x0;

            /**
             * Reset all resettanble settings to factory default, and broadcast all setting values via
             * :ref:`report setting&lt;msg_report_setting&gt;` messages.
             */
            public static final int kResetFactoryDefault = 0x1;

            /**
             * Requests to fetch a single setting from device, with its value reported via the 
             * :ref:`report setting&lt;msg_report_setting&gt;` message. 
             * 
             * This requires the use of the second byte to specify the setting index to fetch.
             */
            public static final int kFetchSettingValue   = 0x2;
        }
    }

    /**
     * Canandgyro bitsets.
     */
    public static class Bitsets {
        private Bitsets() {}

        /**
         * setting_report_flags - Whether the setting set/fetch was successful
         */
        public static final int kSettingReportFlags_SetSuccess = 0x1;

        /**
         * setting_report_flags - Whether the setting synch commit was successful
         */
        public static final int kSettingReportFlags_CommitSuccess = 0x2;

        /**
         * faults - The power cycle fault flag, which is set to true when the device first boots.
         * Clearing sticky faults and then checking this flag can be used to determine if the device rebooted.
         */
        public static final int kFaults_PowerCycle = 0x1;

        /**
         * faults - The CAN ID conflict flag, which is set to true if there is a CAN id conflict.
         * In practice, you should physically inspect the device to ensure it's not flashing blue.
         */
        public static final int kFaults_CanIdConflict = 0x2;

        /**
         * faults - The CAN general error flag, which will raise if the device encounters a CAN fault during operation.
         * If communication with the device still functions, this will not register as an active fault for long if at all.
         * This may raise due to wiring issues, such as an intermittently shorted CAN bus.
         */
        public static final int kFaults_CanGeneralError = 0x4;

        /**
         * faults - The temperature range flag, which will raise if the device is not between 0-70 degrees Celsius.
         * This may be of concern if the device is near very active motors.
         */
        public static final int kFaults_OutOfTemperatureRange = 0x8;

        /**
         * faults - The hardware fault flag, which will raise if a hardware issue is detected.
         * Generally will raise if the device's controller cannot read the physical sensor itself.
         */
        public static final int kFaults_HardwareFault = 0x10;

        /**
         * faults - The calibration status flag, which will raise if the device is currently calibrating.
         */
        public static final int kFaults_Calibrating = 0x20;

        /**
         * faults - The angular velocity saturation flag, which triggers on saturation of angular velocity.
         */
        public static final int kFaults_AngularVelocitySaturation = 0x40;

        /**
         * faults - The acceleration saturation flag, which triggers on saturation of acceleration.
         */
        public static final int kFaults_AccelerationSaturation = 0x80;

        /**
         * Constructs a setting_report_flags bitset.
         * 
         * @param setSuccess Whether the setting set/fetch was successful
         * @param commitSuccess Whether the setting synch commit was successful
         * @return bitset data as int
         */
        public static int constructSettingReportFlags(boolean setSuccess, boolean commitSuccess) {
                return (setSuccess ? 0x1 : 0) | 
                (commitSuccess ? 0x2 : 0);
        }

        /**
         * Constructs a faults bitset.
         * 
         * @param powerCycle The power cycle fault flag, which is set to true when the device first boots.
         * Clearing sticky faults and then checking this flag can be used to determine if the device rebooted.
         * @param canIdConflict The CAN ID conflict flag, which is set to true if there is a CAN id conflict.
         * In practice, you should physically inspect the device to ensure it's not flashing blue.
         * @param canGeneralError The CAN general error flag, which will raise if the device encounters a CAN fault during operation.
         * If communication with the device still functions, this will not register as an active fault for long if at all.
         * This may raise due to wiring issues, such as an intermittently shorted CAN bus.
         * @param outOfTemperatureRange The temperature range flag, which will raise if the device is not between 0-70 degrees Celsius.
         * This may be of concern if the device is near very active motors.
         * @param hardwareFault The hardware fault flag, which will raise if a hardware issue is detected.
         * Generally will raise if the device's controller cannot read the physical sensor itself.
         * @param calibrating The calibration status flag, which will raise if the device is currently calibrating.
         * @param angularVelocitySaturation The angular velocity saturation flag, which triggers on saturation of angular velocity.
         * @param accelerationSaturation The acceleration saturation flag, which triggers on saturation of acceleration.
         * @return bitset data as int
         */
        public static int constructFaults(boolean powerCycle, boolean canIdConflict, boolean canGeneralError, boolean outOfTemperatureRange, boolean hardwareFault, boolean calibrating, boolean angularVelocitySaturation, boolean accelerationSaturation) {
                return (powerCycle ? 0x1 : 0) | 
                (canIdConflict ? 0x2 : 0) | 
                (canGeneralError ? 0x4 : 0) | 
                (outOfTemperatureRange ? 0x8 : 0) | 
                (hardwareFault ? 0x10 : 0) | 
                (calibrating ? 0x20 : 0) | 
                (angularVelocitySaturation ? 0x40 : 0) | 
                (accelerationSaturation ? 0x80 : 0);
        }

        /**
         * Extracts set_success from setting_report_flags.
         * 
         * @param field data bitfield
         * @return true if set, false if not
         */
        public static boolean extractSettingReportFlags_SetSuccess(int field) {
            return (field & kSettingReportFlags_SetSuccess) > 0;
        }

        /**
         * Extracts commit_success from setting_report_flags.
         * 
         * @param field data bitfield
         * @return true if set, false if not
         */
        public static boolean extractSettingReportFlags_CommitSuccess(int field) {
            return (field & kSettingReportFlags_CommitSuccess) > 0;
        }

        /**
         * Extracts power_cycle from faults.
         * 
         * @param field data bitfield
         * @return true if set, false if not
         */
        public static boolean extractFaults_PowerCycle(int field) {
            return (field & kFaults_PowerCycle) > 0;
        }

        /**
         * Extracts can_id_conflict from faults.
         * 
         * @param field data bitfield
         * @return true if set, false if not
         */
        public static boolean extractFaults_CanIdConflict(int field) {
            return (field & kFaults_CanIdConflict) > 0;
        }

        /**
         * Extracts can_general_error from faults.
         * 
         * @param field data bitfield
         * @return true if set, false if not
         */
        public static boolean extractFaults_CanGeneralError(int field) {
            return (field & kFaults_CanGeneralError) > 0;
        }

        /**
         * Extracts out_of_temperature_range from faults.
         * 
         * @param field data bitfield
         * @return true if set, false if not
         */
        public static boolean extractFaults_OutOfTemperatureRange(int field) {
            return (field & kFaults_OutOfTemperatureRange) > 0;
        }

        /**
         * Extracts hardware_fault from faults.
         * 
         * @param field data bitfield
         * @return true if set, false if not
         */
        public static boolean extractFaults_HardwareFault(int field) {
            return (field & kFaults_HardwareFault) > 0;
        }

        /**
         * Extracts calibrating from faults.
         * 
         * @param field data bitfield
         * @return true if set, false if not
         */
        public static boolean extractFaults_Calibrating(int field) {
            return (field & kFaults_Calibrating) > 0;
        }

        /**
         * Extracts angular_velocity_saturation from faults.
         * 
         * @param field data bitfield
         * @return true if set, false if not
         */
        public static boolean extractFaults_AngularVelocitySaturation(int field) {
            return (field & kFaults_AngularVelocitySaturation) > 0;
        }

        /**
         * Extracts acceleration_saturation from faults.
         * 
         * @param field data bitfield
         * @return true if set, false if not
         */
        public static boolean extractFaults_AccelerationSaturation(int field) {
            return (field & kFaults_AccelerationSaturation) > 0;
        }
    }
}