// Copyright (c) Bagholders of Redux Robotics and other contributors.
// This is open source and can be modified and shared under the Mozilla Public License v2.0.

#pragma once
#include <cinttypes>
#include <vector>
#include <cstring>
#include "redux/canand/CanandUtils.h"
#include "redux/canand/CanandAddress.h"

/**
 * Canandcolor protocol-level definitions.
 * 
 * This file is autogenerated by canandmessage, <b>do not hand-edit!</b>
 */
namespace redux::sensors::canandcolor::details {

    /** Types. */
    namespace types {
        /** SettingReportFlags bitset definition */
        class SettingReportFlags {
          public:
            enum : uint8_t {
                /** Whether the setting set/fetch was successful */
                kSetSuccess = 1 << 0,

                /** Whether the setting synch commit was successful */
                kCommitSuccess = 1 << 1,

            };
        };

        /** AtomicAnnouncementFlags bitset definition */
        class AtomicAnnouncementFlags {
          public:
            enum : uint8_t {
                /** Device should enter negotiation phase */
                kNegotiation = 1 << 0,

                /** Device should initialize bus with new rate */
                kInit = 1 << 1,

                /** Device should confirm new bus rate */
                kConfirm = 1 << 2,

                /** Device should begin transmission */
                kBeginTx = 1 << 3,

                /** Device should cease all transmission */
                kBusInterrupt = 1 << 4,

            };
        };

        /** Faults bitset definition */
        class Faults {
          public:
            enum : uint8_t {
                /** The power cycle fault flag, which is set to true when the device first boots.
                Clearing sticky faults and then checking this flag can be used to determine if the device rebooted.
                 */
                kPowerCycle = 1 << 0,

                /** The CAN ID conflict flag, which is set to true if there is a CAN id conflict.
                In practice, you should physically inspect the device to ensure it's not flashing blue.
                 */
                kCanIdConflict = 1 << 1,

                /** The CAN general error flag, which will raise if the device encounters a CAN fault during operation.
                If communication with the device still functions, this will not register as an active fault for long if at all.
                This may raise due to wiring issues, such as an intermittently shorted CAN bus.
                 */
                kCanGeneralError = 1 << 2,

                /** The temperature range flag, which will raise if the device is not between 0-70 degrees Celsius.
                This may be of concern if the device is near very active motors.
                 */
                kOutOfTemperatureRange = 1 << 3,

                /** The hardware fault flag corresponding to the distance sensor IC, which will raise if a hardware issue is detected.
                Generally will raise if the device's controller cannot read the physical sensor itself.
                 */
                kHardwareFaultDistance = 1 << 4,

                /** The hardware fault flag corresponding to the color sensor IC, which will raise if a hardware issue is detected.
                Generally will raise if the device's controller cannot read the physical sensor itself.
                 */
                kHardwareFaultColor = 1 << 5,

                /** The I2C bus recovery flag, which will raise when the device needs to completely restart the I2C bus.
                This fault flag should not be active for very long; if it is stuck as an active fault, that may indicate a hardware issue.
                 */
                kI2cBusRecovery = 1 << 6,

            };
        };

        /** DigoutCond bitset definition */
        class DigoutCond {
          public:
            enum : uint16_t {
                /** Slot 0 */
                kSlot0 = 1 << 0,

                /** Slot 1 */
                kSlot1 = 1 << 1,

                /** Slot 2 */
                kSlot2 = 1 << 2,

                /** Slot 3 */
                kSlot3 = 1 << 3,

                /** Slot 4 */
                kSlot4 = 1 << 4,

                /** Slot 5 */
                kSlot5 = 1 << 5,

                /** Slot 6 */
                kSlot6 = 1 << 6,

                /** Slot 7 */
                kSlot7 = 1 << 7,

                /** Slot 8 */
                kSlot8 = 1 << 8,

                /** Slot 9 */
                kSlot9 = 1 << 9,

                /** Slot 10 */
                kSlot10 = 1 << 10,

                /** Slot 11 */
                kSlot11 = 1 << 11,

                /** Slot 12 */
                kSlot12 = 1 << 12,

                /** Slot 13 */
                kSlot13 = 1 << 13,

                /** Slot 14 */
                kSlot14 = 1 << 14,

                /** Slot 15 */
                kSlot15 = 1 << 15,

            };
        };

        /** ATOMIC_BOND_BUS_RATE enum definition */
        class AtomicBondBusRate {
          public:
            enum : uint8_t {
                /** 1 megabit/s CAN 2.0B */
                kRate1m2b = 0x0,

                /** 1 megabit/s CAN-FD */
                kRateReserved0 = 0x1,

                /** 5 megabit/s CAN-FD */
                kRateReserved1 = 0x2,

                /** 8 megabit/s CAN-FD */
                kRateReserved2 = 0x3,

            };
        };

        /** EXTRA_FRAME_MODE enum definition */
        class ExtraFrameMode {
          public:
            enum : uint8_t {
                /** Do not emit extra frames beyond those specified in the frame period */
                kDisabled = 0x0,

                /** Transmits a frame immidiately once readings change */
                kEarlyTransmitOnChange = 0x1,

            };
        };

        /** DIGOUT_OUTPUT_CONFIG enum definition */
        class DigoutOutputConfig {
          public:
            enum : uint8_t {
                /** Disable output on this pin */
                kDisabled = 0x0,

                /** Use digital logic pin, output 3.3v on true and 0v on false */
                kDigoutLogicActiveHigh = 0x1,

                /** Use digital logic pin, output 0v on true and 3.3v on false */
                kDigoutLogicActiveLow = 0x2,

                /** Output a duty cycle on this pin. Only works on DIG-2 */
                kDutyCycleOutput = 0x3,

            };
        };

        /** SLOT_OPCODE enum definition */
        class SlotOpcode {
          public:
            enum : uint8_t {
                /** true if ``a = b * (imm_scaling + 1) / 256 + (imm_additive)`` */
                kEquals = 0x0,

                /** true if ``a < b * (imm_scaling + 1) / 256 + (imm_additive)`` */
                kLessThan = 0x1,

                /** true if ``a > b * (imm_scaling + 1) / 256 + (imm_additive)`` */
                kGreaterThan = 0x2,

                /** true if ``a <= b * (imm_scaling + 1) / 256 + (imm_additive)`` */
                kLessThanOrEquals = 0x3,

                /** true if``a >= b * (imm_scaling + 1) / 256 + (imm_additive)`` */
                kGreaterThanOrEquals = 0x4,

                /** true if previous slot true for ``b * (imm_scaling + 1) / 256 + (imm_additive)`` milliseconds */
                kPrevSlotTrue = 0x5,

                /** true if previous joined-slot-chain true for ``b * (imm_scaling + 1) / 256 + (imm_additive)`` milliseconds */
                kPrevClauseTrue = 0x6,

            };
        };

        /** NEXT_SLOT_ACTION enum definition */
        class NextSlotAction {
          public:
            enum : uint8_t {
                /** Do not interact with the next slot */
                kTerminateChain = 0x0,

                /** Logical OR with next slot */
                kOrWithNextSlot = 0x1,

                /** Logical XOR with next slot */
                kXorWithNextSlot = 0x2,

                /** Logical AND with next slot */
                kAndWithNextSlot = 0x3,

            };
        };

        /** DATA_SOURCE enum definition */
        class DataSource {
          public:
            enum : uint8_t {
                /** Always reads zero; can be used to compare only to additive immidate0 */
                kZero = 0x0,

                /** Distance reading */
                kDistance = 0x1,

                /** Red reading */
                kRed = 0x2,

                /** Green reading */
                kGreen = 0x3,

                /** Blue reading */
                kBlue = 0x4,

                /** Hue reading */
                kHue = 0x5,

                /** Saturation reading */
                kSaturation = 0x6,

                /** Value reading */
                kValue = 0x7,

            };
        };

        /** COLOR_INTEGRATION_PERIOD enum definition */
        class ColorIntegrationPeriod {
          public:
            enum : uint8_t {
                /** 400 ms - 20 bit resolution */
                kPeriod400MsResolution20Bit = 0x0,

                /** 200 ms - 19 bit resolution */
                kPeriod200MsResolution19Bit = 0x1,

                /** 100 ms - 18 bit resolution */
                kPeriod100MsResolution18Bit = 0x2,

                /** 50 ms - 17 bit resolution */
                kPeriod50MsResolution17Bit = 0x3,

                /** 25 ms - 16 bit resolution */
                kPeriod25MsResolution16Bit = 0x4,

            };
        };

        /** DISTANCE_INTEGRATION_PERIOD enum definition */
        class DistanceIntegrationPeriod {
          public:
            enum : uint8_t {
                /** 5 millisecond period */
                kPeriod5Ms = 0x0,

                /** 7.5 millisecond period */
                kPeriod7p5Ms = 0x1,

                /** 10 millisecond period */
                kPeriod10Ms = 0x2,

                /** 12.5 millisecond period */
                kPeriod12p5Ms = 0x3,

                /** 15 millisecond period */
                kPeriod15Ms = 0x4,

                /** 17.5 millisecond period */
                kPeriod17p5Ms = 0x5,

                /** 20 millisecond period */
                kPeriod20Ms = 0x6,

                /** 40 millisecond period */
                kPeriod40Ms = 0x7,

            };
        };

        /** SETTING_COMMAND enum definition */
        class SettingCommand {
          public:
            enum : uint8_t {
                /** Fetch all settings from device via a series of :ref:`report setting<msg_report_setting>` messages of all indexes */
                kFetchSettings = 0x0,

                /** Reset all resettanble settings to factory default, and broadcast all setting values via
                :ref:`report setting<msg_report_setting>` messages.
                 */
                kResetFactoryDefault = 0x1,

                /** Requests to fetch a single setting from device, with its value reported via the 
                :ref:`report setting<msg_report_setting>` message. 

                This requires the use of the second byte to specify the setting index to fetch. */
                kFetchSettingValue = 0x2,

                /** Clear all digout1 slots */
                kClearDigout1 = 0xff,

                /** Clear all digout2 slots */
                kClearDigout2 = 0xfe,

                /** Fetch all digout1 slots and settings */
                kFetchDigout1 = 0xfd,

                /** Fetch all digout2 slots and settings */
                kFetchDigout2 = 0xfc,

            };
        };

        /** setting_flags definition */
        struct SettingFlags {
          public:
            /** Whether the setting should be set ephemeral */
            bool ephemeral;

            /** Whether the setting should be held until the next synch barrier */
            bool synch_hold;

            /** Synch message count */
            uint8_t synch_msg_count;

            /**
             * Decodes a struct.
             * 
             * @param data intfield to decode
             * @return a decoded struct
             */
            static constexpr SettingFlags decode(uint64_t data) {
                return SettingFlags {
                    .ephemeral = redux::canand::utils::extractBool(data, 0),
                    .synch_hold = redux::canand::utils::extractBool(data, 1),
                    .synch_msg_count = redux::canand::utils::extractU8(data, 4, 4),  
                };
            }

            /**
             * Encodes a struct.
             *
             * @return an encoded struct.
             */
            constexpr uint64_t encode() {
                return (
                    0 |
                    redux::canand::utils::packBool(this->ephemeral, 0) |
                    redux::canand::utils::packBool(this->synch_hold, 1) |
                    redux::canand::utils::packUInt(this->synch_msg_count, 4, 4) 
                );
            }


        };

        /** firmware_version definition */
        struct FirmwareVersion {
          public:
            /** Firmware version patch number */
            uint8_t firmware_patch;

            /** Firmware version minor number */
            uint8_t firmware_minor;

            /** Firmware version year */
            uint16_t firmware_year;

            /**
             * Decodes a struct.
             * 
             * @param data intfield to decode
             * @return a decoded struct
             */
            static constexpr FirmwareVersion decode(uint64_t data) {
                return FirmwareVersion {
                    .firmware_patch = redux::canand::utils::extractU8(data, 8, 0),
                    .firmware_minor = redux::canand::utils::extractU8(data, 8, 8),
                    .firmware_year = redux::canand::utils::extractU16(data, 16, 16),  
                };
            }

            /**
             * Encodes a struct.
             *
             * @return an encoded struct.
             */
            constexpr uint64_t encode() {
                return (
                    0 |
                    redux::canand::utils::packUInt(this->firmware_patch, 8, 0) |
                    redux::canand::utils::packUInt(this->firmware_minor, 8, 8) |
                    redux::canand::utils::packUInt(this->firmware_year, 16, 16) 
                );
            }


        };

        /** digout_control_config definition */
        struct DigoutControlConfig {
          public:
            /** Enable digout pad */
            uint8_t output_config;

            /** The data source to use in PWM mode. */
            uint8_t pwm_data_source;

            /**
             * Decodes a struct.
             * 
             * @param data intfield to decode
             * @return a decoded struct
             */
            static constexpr DigoutControlConfig decode(uint64_t data) {
                return DigoutControlConfig {
                    .output_config = redux::canand::utils::extractU8(data, 8, 0),
                    .pwm_data_source = redux::canand::utils::extractU8(data, 4, 8),  
                };
            }

            /**
             * Encodes a struct.
             *
             * @return an encoded struct.
             */
            constexpr uint64_t encode() {
                return (
                    0 |
                    redux::canand::utils::packUInt(this->output_config, 8, 0) |
                    redux::canand::utils::packUInt(this->pwm_data_source, 4, 8) 
                );
            }


        };

        /** digout_message_trigger definition */
        struct DigoutMessageTrigger {
          public:
            /** Send digout message on positive edge (false->true) */
            bool positive_edge;

            /** Send digout message on negative edge (true->false) */
            bool negative_edge;

            /**
             * Decodes a struct.
             * 
             * @param data intfield to decode
             * @return a decoded struct
             */
            static constexpr DigoutMessageTrigger decode(uint64_t data) {
                return DigoutMessageTrigger {
                    .positive_edge = redux::canand::utils::extractBool(data, 0),
                    .negative_edge = redux::canand::utils::extractBool(data, 1),  
                };
            }

            /**
             * Encodes a struct.
             *
             * @return an encoded struct.
             */
            constexpr uint64_t encode() {
                return (
                    0 |
                    redux::canand::utils::packBool(this->positive_edge, 0) |
                    redux::canand::utils::packBool(this->negative_edge, 1) 
                );
            }


        };

        /** digout_slot definition */
        struct DigoutSlot {
          public:
            /** Enable the digout slot */
            bool slot_enabled;

            /** How the digout slot interacts with the next slot */
            uint8_t next_slot_action;

            /** Invert the digout slot's boolean value */
            bool invert_value;

            /** Opcode */
            uint8_t opcode;

            /** Additive immidiate */
            int32_t immidiate_additive;

            /** Scaling immidiate */
            uint8_t immidiate_scaling;

            /** First ``LHS`` data source */
            uint8_t data_source_a;

            /** Second ``RHS`` data source */
            uint8_t data_source_b;

            /**
             * Decodes a struct.
             * 
             * @param data intfield to decode
             * @return a decoded struct
             */
            static constexpr DigoutSlot decode(uint64_t data) {
                return DigoutSlot {
                    .slot_enabled = redux::canand::utils::extractBool(data, 0),
                    .next_slot_action = redux::canand::utils::extractU8(data, 2, 1),
                    .invert_value = redux::canand::utils::extractBool(data, 3),
                    .opcode = redux::canand::utils::extractU8(data, 7, 4),
                    .immidiate_additive = redux::canand::utils::extractI32(data, 21, 11),
                    .immidiate_scaling = redux::canand::utils::extractU8(data, 8, 32),
                    .data_source_a = redux::canand::utils::extractU8(data, 4, 40),
                    .data_source_b = redux::canand::utils::extractU8(data, 4, 44),  
                };
            }

            /**
             * Encodes a struct.
             *
             * @return an encoded struct.
             */
            constexpr uint64_t encode() {
                return (
                    0 |
                    redux::canand::utils::packBool(this->slot_enabled, 0) |
                    redux::canand::utils::packUInt(this->next_slot_action, 2, 1) |
                    redux::canand::utils::packBool(this->invert_value, 3) |
                    redux::canand::utils::packUInt(this->opcode, 7, 4) |
                    redux::canand::utils::packInt(this->immidiate_additive, 21, 11) |
                    redux::canand::utils::packUInt(this->immidiate_scaling, 8, 32) |
                    redux::canand::utils::packUInt(this->data_source_a, 4, 40) |
                    redux::canand::utils::packUInt(this->data_source_b, 4, 44) 
                );
            }


        };

    }

    /** Messages. */
    namespace msg {
        enum : uint8_t {
            /** setting control command */
            kSettingCommand = 0x2,

            /** update setting on device */
            kSetSetting = 0x3,

            /** setting value report from device */
            kReportSetting = 0x4,

            /** Clear device sticky faults */
            kClearStickyFaults = 0x5,

            /** Status frame */
            kStatus = 0x6,

            /** Party mode */
            kPartyMode = 0x7,

            /** Device enumerate response */
            kEnumerate = 0xb,

            /** Distance frame */
            kDistanceOutput = 0x1f,

            /** Color frame */
            kColorOutput = 0x1e,

            /** Digital output frame */
            kDigitalOutput = 0x1d,

            /** Clear sticky digout state which is broadcast over CAN */
            kClearStickyDigout = 0x1c,

        };
        /** setting control command struct */
        struct SettingCommand {
          public:
            /** Setting command index */
            uint8_t control_flag;

            /** setting index to fetch */
            uint8_t setting_index;

            /**
             * Decodes a struct.
             * 
             * @param data intfield to decode
             * @return a decoded struct
             */
            static constexpr SettingCommand decode(uint64_t data) {
                return SettingCommand {
                    .control_flag = redux::canand::utils::extractU8(data, 8, 0),
                    .setting_index = redux::canand::utils::extractU8(data, 8, 8),  
                };
            }

            /**
             * Encodes a struct.
             *
             * @return an encoded struct.
             */
            constexpr uint64_t encode() {
                return (
                    0 |
                    redux::canand::utils::packUInt(this->control_flag, 8, 0) |
                    redux::canand::utils::packUInt(this->setting_index, 8, 8) 
                );
            }


            /** Minimum acceptable data length code for this message */
            static const uint32_t DLC_MIN = 1;

            /** Maximum acceptable data length code for this message */
            static const uint32_t DLC_MAX = 8;

            /**
             * Sends the message struct to a CanandAddress.
             * @param addr the address to send to
             * @return the return value of SendCANMessage
             */
            inline bool send(redux::canand::CanandAddress& addr) {
                uint64_t data = this->encode();
                return addr.SendCANMessage(msg::kSettingCommand, (uint8_t*) &data, 8);
            }

        };

        /** update setting on device struct */
        struct SetSetting {
          public:
            /** Setting index to write to */
            uint8_t address;

            /** 6-byte setting value */
            uint64_t value;

            /** Setting flags */
            types::SettingFlags flags;

            /**
             * Decodes a struct.
             * 
             * @param data intfield to decode
             * @return a decoded struct
             */
            static constexpr SetSetting decode(uint64_t data) {
                return SetSetting {
                    .address = redux::canand::utils::extractU8(data, 8, 0),
                    .value = redux::canand::utils::extractU64(data, 48, 8),
                    .flags = types::SettingFlags::decode(data >> 56),  
                };
            }

            /**
             * Encodes a struct.
             *
             * @return an encoded struct.
             */
            constexpr uint64_t encode() {
                return (
                    0 |
                    redux::canand::utils::packUInt(this->address, 8, 0) |
                    redux::canand::utils::packUInt(this->value, 48, 8) |
                    (this->flags.encode() << 56) 
                );
            }


            /** Minimum acceptable data length code for this message */
            static const uint32_t DLC_MIN = 8;

            /** Maximum acceptable data length code for this message */
            static const uint32_t DLC_MAX = 8;

            /**
             * Sends the message struct to a CanandAddress.
             * @param addr the address to send to
             * @return the return value of SendCANMessage
             */
            inline bool send(redux::canand::CanandAddress& addr) {
                uint64_t data = this->encode();
                return addr.SendCANMessage(msg::kSetSetting, (uint8_t*) &data, 8);
            }

        };

        /** setting value report from device struct */
        struct ReportSetting {
          public:
            /** Setting index to write to */
            uint8_t address;

            /** 6-byte setting value */
            uint64_t value;

            /** Setting receive status */
            uint8_t flags;

            /**
             * Decodes a struct.
             * 
             * @param data intfield to decode
             * @return a decoded struct
             */
            static constexpr ReportSetting decode(uint64_t data) {
                return ReportSetting {
                    .address = redux::canand::utils::extractU8(data, 8, 0),
                    .value = redux::canand::utils::extractU64(data, 48, 8),
                    .flags = redux::canand::utils::extractU8(data, 8, 56),  
                };
            }

            /**
             * Encodes a struct.
             *
             * @return an encoded struct.
             */
            constexpr uint64_t encode() {
                return (
                    0 |
                    redux::canand::utils::packUInt(this->address, 8, 0) |
                    redux::canand::utils::packUInt(this->value, 48, 8) |
                    redux::canand::utils::packUInt(this->flags, 8, 56) 
                );
            }


            /** Minimum acceptable data length code for this message */
            static const uint32_t DLC_MIN = 8;

            /** Maximum acceptable data length code for this message */
            static const uint32_t DLC_MAX = 8;

            /**
             * Sends the message struct to a CanandAddress.
             * @param addr the address to send to
             * @return the return value of SendCANMessage
             */
            inline bool send(redux::canand::CanandAddress& addr) {
                uint64_t data = this->encode();
                return addr.SendCANMessage(msg::kReportSetting, (uint8_t*) &data, 8);
            }

        };

        /** Clear device sticky faults struct */
        struct ClearStickyFaults {
          public:

            /**
             * Decodes a struct.
             * 
             * @param data intfield to decode
             * @return a decoded struct
             */
            static constexpr ClearStickyFaults decode(uint64_t data) {
                return ClearStickyFaults {
  
                };
            }

            /**
             * Encodes a struct.
             *
             * @return an encoded struct.
             */
            constexpr uint64_t encode() {
                return (
                    0 
                );
            }


            /** Minimum acceptable data length code for this message */
            static const uint32_t DLC_MIN = 0;

            /** Maximum acceptable data length code for this message */
            static const uint32_t DLC_MAX = 8;

            /**
             * Sends the message struct to a CanandAddress.
             * @param addr the address to send to
             * @return the return value of SendCANMessage
             */
            inline bool send(redux::canand::CanandAddress& addr) {
                uint64_t data = this->encode();
                return addr.SendCANMessage(msg::kClearStickyFaults, (uint8_t*) &data, 8);
            }

        };

        /** Status frame struct */
        struct Status {
          public:
            /** 8-bit active faults bitfield */
            uint8_t faults;

            /** 8-bit sticky faults bitfield */
            uint8_t sticky_faults;

            /** 16-bit signed temperature byte in 1/256ths of a Celsius */
            int16_t temperature;

            /**
             * Decodes a struct.
             * 
             * @param data intfield to decode
             * @return a decoded struct
             */
            static constexpr Status decode(uint64_t data) {
                return Status {
                    .faults = redux::canand::utils::extractU8(data, 8, 0),
                    .sticky_faults = redux::canand::utils::extractU8(data, 8, 8),
                    .temperature = redux::canand::utils::extractI16(data, 16, 16),  
                };
            }

            /**
             * Encodes a struct.
             *
             * @return an encoded struct.
             */
            constexpr uint64_t encode() {
                return (
                    0 |
                    redux::canand::utils::packUInt(this->faults, 8, 0) |
                    redux::canand::utils::packUInt(this->sticky_faults, 8, 8) |
                    redux::canand::utils::packInt(this->temperature, 16, 16) 
                );
            }


            /** Minimum acceptable data length code for this message */
            static const uint32_t DLC_MIN = 8;

            /** Maximum acceptable data length code for this message */
            static const uint32_t DLC_MAX = 8;

            /**
             * Sends the message struct to a CanandAddress.
             * @param addr the address to send to
             * @return the return value of SendCANMessage
             */
            inline bool send(redux::canand::CanandAddress& addr) {
                uint64_t data = this->encode();
                return addr.SendCANMessage(msg::kStatus, (uint8_t*) &data, 8);
            }

        };

        /** Party mode struct */
        struct PartyMode {
          public:
            /** Party level. 0 disables the strobe, whereas 1 enables it. */
            uint8_t party_level;

            /**
             * Decodes a struct.
             * 
             * @param data intfield to decode
             * @return a decoded struct
             */
            static constexpr PartyMode decode(uint64_t data) {
                return PartyMode {
                    .party_level = redux::canand::utils::extractU8(data, 8, 0),  
                };
            }

            /**
             * Encodes a struct.
             *
             * @return an encoded struct.
             */
            constexpr uint64_t encode() {
                return (
                    0 |
                    redux::canand::utils::packUInt(this->party_level, 8, 0) 
                );
            }


            /** Minimum acceptable data length code for this message */
            static const uint32_t DLC_MIN = 1;

            /** Maximum acceptable data length code for this message */
            static const uint32_t DLC_MAX = 8;

            /**
             * Sends the message struct to a CanandAddress.
             * @param addr the address to send to
             * @return the return value of SendCANMessage
             */
            inline bool send(redux::canand::CanandAddress& addr) {
                uint64_t data = this->encode();
                return addr.SendCANMessage(msg::kPartyMode, (uint8_t*) &data, 8);
            }

        };

        /** Device enumerate response struct */
        struct Enumerate {
          public:
            /** Device-unique serial number */
            uint64_t serial;

            /** Device is in bootloader. */
            bool is_bootloader;

            /**
             * Decodes a struct.
             * 
             * @param data intfield to decode
             * @return a decoded struct
             */
            static constexpr Enumerate decode(uint64_t data) {
                return Enumerate {
                    .serial = redux::canand::utils::extractU64(data, 48, 0),
                    .is_bootloader = redux::canand::utils::extractBool(data, 48),  
                };
            }

            /**
             * Encodes a struct.
             *
             * @return an encoded struct.
             */
            constexpr uint64_t encode() {
                return (
                    0 |
                    redux::canand::utils::packUInt(this->serial, 48, 0) |
                    redux::canand::utils::packBool(this->is_bootloader, 48) 
                );
            }


            /** Minimum acceptable data length code for this message */
            static const uint32_t DLC_MIN = 8;

            /** Maximum acceptable data length code for this message */
            static const uint32_t DLC_MAX = 8;

            /**
             * Sends the message struct to a CanandAddress.
             * @param addr the address to send to
             * @return the return value of SendCANMessage
             */
            inline bool send(redux::canand::CanandAddress& addr) {
                uint64_t data = this->encode();
                return addr.SendCANMessage(msg::kEnumerate, (uint8_t*) &data, 8);
            }

        };

        /** Distance frame struct */
        struct DistanceOutput {
          public:
            /** 16-bit distance value. Actual correspondance to real-world units is config and surface-dependent. */
            uint16_t distance;

            /**
             * Decodes a struct.
             * 
             * @param data intfield to decode
             * @return a decoded struct
             */
            static constexpr DistanceOutput decode(uint64_t data) {
                return DistanceOutput {
                    .distance = redux::canand::utils::extractU16(data, 16, 0),  
                };
            }

            /**
             * Encodes a struct.
             *
             * @return an encoded struct.
             */
            constexpr uint64_t encode() {
                return (
                    0 |
                    redux::canand::utils::packUInt(this->distance, 16, 0) 
                );
            }


            /** Minimum acceptable data length code for this message */
            static const uint32_t DLC_MIN = 2;

            /** Maximum acceptable data length code for this message */
            static const uint32_t DLC_MAX = 2;

            /**
             * Sends the message struct to a CanandAddress.
             * @param addr the address to send to
             * @return the return value of SendCANMessage
             */
            inline bool send(redux::canand::CanandAddress& addr) {
                uint64_t data = this->encode();
                return addr.SendCANMessage(msg::kDistanceOutput, (uint8_t*) &data, 2);
            }

        };

        /** Color frame struct */
        struct ColorOutput {
          public:
            /** Red reading magnitude */
            uint32_t red;

            /** Green reading magnitude */
            uint32_t green;

            /** Blue reading magnitude */
            uint32_t blue;

            /** Color integration period */
            uint8_t period;

            /**
             * Decodes a struct.
             * 
             * @param data intfield to decode
             * @return a decoded struct
             */
            static constexpr ColorOutput decode(uint64_t data) {
                return ColorOutput {
                    .red = redux::canand::utils::extractU32(data, 20, 0),
                    .green = redux::canand::utils::extractU32(data, 20, 20),
                    .blue = redux::canand::utils::extractU32(data, 20, 40),
                    .period = redux::canand::utils::extractU8(data, 4, 60),  
                };
            }

            /**
             * Encodes a struct.
             *
             * @return an encoded struct.
             */
            constexpr uint64_t encode() {
                return (
                    0 |
                    redux::canand::utils::packUInt(this->red, 20, 0) |
                    redux::canand::utils::packUInt(this->green, 20, 20) |
                    redux::canand::utils::packUInt(this->blue, 20, 40) |
                    redux::canand::utils::packUInt(this->period, 4, 60) 
                );
            }


            /** Minimum acceptable data length code for this message */
            static const uint32_t DLC_MIN = 8;

            /** Maximum acceptable data length code for this message */
            static const uint32_t DLC_MAX = 8;

            /**
             * Sends the message struct to a CanandAddress.
             * @param addr the address to send to
             * @return the return value of SendCANMessage
             */
            inline bool send(redux::canand::CanandAddress& addr) {
                uint64_t data = this->encode();
                return addr.SendCANMessage(msg::kColorOutput, (uint8_t*) &data, 8);
            }

        };

        /** Digital output frame struct */
        struct DigitalOutput {
          public:
            /** Digital output state for DIGOUT1 */
            bool digout1_state;

            /** Digital output state for DIGOUT2 */
            bool digout2_state;

            /** Sticky digital output state for DIGOUT1 */
            bool digout1_sticky;

            /** Sticky digital output state for DIGOUT1 */
            bool digout2_sticky;

            /** DIGOUT1 condition slot flags. A value of 1 for bit N means that condition slot is true. Bits are indexed little-endian. */
            uint16_t digout1_cond;

            /** DIGOUT2 condition slot flags. A value of 1 for bit N means that condition slot is true. Bits are indexed little-endian. */
            uint16_t digout2_cond;

            /**
             * Decodes a struct.
             * 
             * @param data intfield to decode
             * @return a decoded struct
             */
            static constexpr DigitalOutput decode(uint64_t data) {
                return DigitalOutput {
                    .digout1_state = redux::canand::utils::extractBool(data, 0),
                    .digout2_state = redux::canand::utils::extractBool(data, 1),
                    .digout1_sticky = redux::canand::utils::extractBool(data, 2),
                    .digout2_sticky = redux::canand::utils::extractBool(data, 3),
                    .digout1_cond = redux::canand::utils::extractU16(data, 16, 8),
                    .digout2_cond = redux::canand::utils::extractU16(data, 16, 24),  
                };
            }

            /**
             * Encodes a struct.
             *
             * @return an encoded struct.
             */
            constexpr uint64_t encode() {
                return (
                    0 |
                    redux::canand::utils::packBool(this->digout1_state, 0) |
                    redux::canand::utils::packBool(this->digout2_state, 1) |
                    redux::canand::utils::packBool(this->digout1_sticky, 2) |
                    redux::canand::utils::packBool(this->digout2_sticky, 3) |
                    redux::canand::utils::packUInt(this->digout1_cond, 16, 8) |
                    redux::canand::utils::packUInt(this->digout2_cond, 16, 24) 
                );
            }


            /** Minimum acceptable data length code for this message */
            static const uint32_t DLC_MIN = 5;

            /** Maximum acceptable data length code for this message */
            static const uint32_t DLC_MAX = 5;

            /**
             * Sends the message struct to a CanandAddress.
             * @param addr the address to send to
             * @return the return value of SendCANMessage
             */
            inline bool send(redux::canand::CanandAddress& addr) {
                uint64_t data = this->encode();
                return addr.SendCANMessage(msg::kDigitalOutput, (uint8_t*) &data, 5);
            }

        };

        /** Clear sticky digout state which is broadcast over CAN struct */
        struct ClearStickyDigout {
          public:

            /**
             * Decodes a struct.
             * 
             * @param data intfield to decode
             * @return a decoded struct
             */
            static constexpr ClearStickyDigout decode(uint64_t data) {
                return ClearStickyDigout {
  
                };
            }

            /**
             * Encodes a struct.
             *
             * @return an encoded struct.
             */
            constexpr uint64_t encode() {
                return (
                    0 
                );
            }


            /** Minimum acceptable data length code for this message */
            static const uint32_t DLC_MIN = 0;

            /** Maximum acceptable data length code for this message */
            static const uint32_t DLC_MAX = 0;

            /**
             * Sends the message struct to a CanandAddress.
             * @param addr the address to send to
             * @return the return value of SendCANMessage
             */
            inline bool send(redux::canand::CanandAddress& addr) {
                uint64_t data = this->encode();
                return addr.SendCANMessage(msg::kClearStickyDigout, (uint8_t*) &data, 0);
            }

        };

    }

    /** Settings. */
    namespace setting {
        enum : uint8_t {
            /** Status frame period (ms) */
            kStatusFramePeriod = 0x4,

            /** Serial number */
            kSerialNumber = 0x5,

            /** Firmware version */
            kFirmwareVersion = 0x6,

            /** Device-specific type identifier */
            kDeviceType = 0x8,

            /** User-writable scratch bytes 1 */
            kScratch0 = 0x9,

            /** User-writable scratch bytes 2 */
            kScratch1 = 0xa,

            /** Distance frame period (ms) */
            kDistanceFramePeriod = 0xff,

            /** Color frame period (ms) */
            kColorFramePeriod = 0xfe,

            /** Digout frame period (ms) */
            kDigoutFramePeriod = 0xfd,

            /** Distance extra frame mode */
            kDistanceExtraFrameMode = 0xf7,

            /** Color extra frame frame mode */
            kColorExtraFrameMode = 0xf6,

            /** Lamp LED brightness */
            kLampBrightness = 0xef,

            /** Color integration period */
            kColorIntegrationPeriod = 0xee,

            /** Distance integration period */
            kDistanceIntegrationPeriod = 0xed,

            /** Digital output 1 control config */
            kDigout1OutputConfig = 0xeb,

            /** Digital output 2 control config */
            kDigout2OutputConfig = 0xea,

            /** Digital output 1 send message on change */
            kDigout1MessageOnChange = 0xe9,

            /** Digital output 2 send message on change */
            kDigout2MessageOnChange = 0xe8,

            /** Digout1 config slot 0 */
            kDigout1Config0 = 0xd0,

            /** Digout1 config slot 1 */
            kDigout1Config1 = 0xcf,

            /** Digout1 config slot 2 */
            kDigout1Config2 = 0xce,

            /** Digout1 config slot 3 */
            kDigout1Config3 = 0xcd,

            /** Digout1 config slot 4 */
            kDigout1Config4 = 0xcc,

            /** Digout1 config slot 5 */
            kDigout1Config5 = 0xcb,

            /** Digout1 config slot 6 */
            kDigout1Config6 = 0xca,

            /** Digout1 config slot 7 */
            kDigout1Config7 = 0xc9,

            /** Digout1 config slot 8 */
            kDigout1Config8 = 0xc8,

            /** Digout1 config slot 9 */
            kDigout1Config9 = 0xc7,

            /** Digout1 config slot 10 */
            kDigout1Config10 = 0xc6,

            /** Digout1 config slot 11 */
            kDigout1Config11 = 0xc5,

            /** Digout1 config slot 12 */
            kDigout1Config12 = 0xc4,

            /** Digout1 config slot 13 */
            kDigout1Config13 = 0xc3,

            /** Digout1 config slot 14 */
            kDigout1Config14 = 0xc2,

            /** Digout1 config slot 15 */
            kDigout1Config15 = 0xc1,

            /** Digout2 config slot 0 */
            kDigout2Config0 = 0xc0,

            /** Digout2 config slot 1 */
            kDigout2Config1 = 0xbf,

            /** Digout2 config slot 2 */
            kDigout2Config2 = 0xbe,

            /** Digout2 config slot 3 */
            kDigout2Config3 = 0xbd,

            /** Digout2 config slot 4 */
            kDigout2Config4 = 0xbc,

            /** Digout2 config slot 5 */
            kDigout2Config5 = 0xbb,

            /** Digout2 config slot 6 */
            kDigout2Config6 = 0xba,

            /** Digout2 config slot 7 */
            kDigout2Config7 = 0xb9,

            /** Digout2 config slot 8 */
            kDigout2Config8 = 0xb8,

            /** Digout2 config slot 9 */
            kDigout2Config9 = 0xb7,

            /** Digout2 config slot 10 */
            kDigout2Config10 = 0xb6,

            /** Digout2 config slot 11 */
            kDigout2Config11 = 0xb5,

            /** Digout2 config slot 12 */
            kDigout2Config12 = 0xb4,

            /** Digout2 config slot 13 */
            kDigout2Config13 = 0xb3,

            /** Digout2 config slot 14 */
            kDigout2Config14 = 0xb2,

            /** Digout2 config slot 15 */
            kDigout2Config15 = 0xb1,

        };
        /** 
         * Construct setting STATUS_FRAME_PERIOD 
         * @param data the data to pack into a setting bitfield
         * @return 48-bit data field of settings in the wire format
         */
        inline uint64_t constructStatusFramePeriod(uint16_t data) {
            return redux::canand::utils::packUInt(data, 16, 0);
        }

        /** 
         * Unpack setting STATUS_FRAME_PERIOD from the wire format.
         * @param data the 48-bit data field to extract a setting struct from.
         * @return a setting struct
         */
        inline uint16_t extractStatusFramePeriod(uint64_t data) {
            return redux::canand::utils::extractU16(data, 16, 0);
        }

        /** 
         * Construct setting SERIAL_NUMBER 
         * @param data the data to pack into a setting bitfield
         * @return 48-bit data field of settings in the wire format
         */
        inline uint64_t constructSerialNumber(uint64_t data) {
            return redux::canand::utils::packUInt(data, 48, 0);
        }

        /** 
         * Unpack setting SERIAL_NUMBER from the wire format.
         * @param data the 48-bit data field to extract a setting struct from.
         * @return a setting struct
         */
        inline uint64_t extractSerialNumber(uint64_t data) {
            return redux::canand::utils::extractU64(data, 48, 0);
        }

        /** 
         * Construct setting FIRMWARE_VERSION 
         * @param data the data to pack into a setting bitfield
         * @return 48-bit data field of settings in the wire format
         */
        inline uint64_t constructFirmwareVersion(types::FirmwareVersion data) {
            return (data.encode() << 0);
        }

        /** 
         * Unpack setting FIRMWARE_VERSION from the wire format.
         * @param data the 48-bit data field to extract a setting struct from.
         * @return a setting struct
         */
        inline types::FirmwareVersion extractFirmwareVersion(uint64_t data) {
            return types::FirmwareVersion::decode(data >> 0);
        }

        /** 
         * Construct setting DEVICE_TYPE 
         * @param data the data to pack into a setting bitfield
         * @return 48-bit data field of settings in the wire format
         */
        inline uint64_t constructDeviceType(uint16_t data) {
            return redux::canand::utils::packUInt(data, 16, 0);
        }

        /** 
         * Unpack setting DEVICE_TYPE from the wire format.
         * @param data the 48-bit data field to extract a setting struct from.
         * @return a setting struct
         */
        inline uint16_t extractDeviceType(uint64_t data) {
            return redux::canand::utils::extractU16(data, 16, 0);
        }

        /** 
         * Construct setting SCRATCH_0 
         * @param data the data to pack into a setting bitfield
         * @return 48-bit data field of settings in the wire format
         */
        inline uint64_t constructScratch0(uint64_t data) {
            return redux::canand::utils::packUInt(data, 48, 0);
        }

        /** 
         * Unpack setting SCRATCH_0 from the wire format.
         * @param data the 48-bit data field to extract a setting struct from.
         * @return a setting struct
         */
        inline uint64_t extractScratch0(uint64_t data) {
            return redux::canand::utils::extractU64(data, 48, 0);
        }

        /** 
         * Construct setting SCRATCH_1 
         * @param data the data to pack into a setting bitfield
         * @return 48-bit data field of settings in the wire format
         */
        inline uint64_t constructScratch1(uint64_t data) {
            return redux::canand::utils::packUInt(data, 48, 0);
        }

        /** 
         * Unpack setting SCRATCH_1 from the wire format.
         * @param data the 48-bit data field to extract a setting struct from.
         * @return a setting struct
         */
        inline uint64_t extractScratch1(uint64_t data) {
            return redux::canand::utils::extractU64(data, 48, 0);
        }

        /** 
         * Construct setting DISTANCE_FRAME_PERIOD 
         * @param data the data to pack into a setting bitfield
         * @return 48-bit data field of settings in the wire format
         */
        inline uint64_t constructDistanceFramePeriod(uint16_t data) {
            return redux::canand::utils::packUInt(data, 16, 0);
        }

        /** 
         * Unpack setting DISTANCE_FRAME_PERIOD from the wire format.
         * @param data the 48-bit data field to extract a setting struct from.
         * @return a setting struct
         */
        inline uint16_t extractDistanceFramePeriod(uint64_t data) {
            return redux::canand::utils::extractU16(data, 16, 0);
        }

        /** 
         * Construct setting COLOR_FRAME_PERIOD 
         * @param data the data to pack into a setting bitfield
         * @return 48-bit data field of settings in the wire format
         */
        inline uint64_t constructColorFramePeriod(uint16_t data) {
            return redux::canand::utils::packUInt(data, 16, 0);
        }

        /** 
         * Unpack setting COLOR_FRAME_PERIOD from the wire format.
         * @param data the 48-bit data field to extract a setting struct from.
         * @return a setting struct
         */
        inline uint16_t extractColorFramePeriod(uint64_t data) {
            return redux::canand::utils::extractU16(data, 16, 0);
        }

        /** 
         * Construct setting DIGOUT_FRAME_PERIOD 
         * @param data the data to pack into a setting bitfield
         * @return 48-bit data field of settings in the wire format
         */
        inline uint64_t constructDigoutFramePeriod(uint16_t data) {
            return redux::canand::utils::packUInt(data, 16, 0);
        }

        /** 
         * Unpack setting DIGOUT_FRAME_PERIOD from the wire format.
         * @param data the 48-bit data field to extract a setting struct from.
         * @return a setting struct
         */
        inline uint16_t extractDigoutFramePeriod(uint64_t data) {
            return redux::canand::utils::extractU16(data, 16, 0);
        }

        /** 
         * Construct setting DISTANCE_EXTRA_FRAME_MODE 
         * @param data the data to pack into a setting bitfield
         * @return 48-bit data field of settings in the wire format
         */
        inline uint64_t constructDistanceExtraFrameMode(uint8_t data) {
            return redux::canand::utils::packUInt(data, 8, 0);
        }

        /** 
         * Unpack setting DISTANCE_EXTRA_FRAME_MODE from the wire format.
         * @param data the 48-bit data field to extract a setting struct from.
         * @return a setting struct
         */
        inline uint8_t extractDistanceExtraFrameMode(uint64_t data) {
            return redux::canand::utils::extractU8(data, 8, 0);
        }

        /** 
         * Construct setting COLOR_EXTRA_FRAME_MODE 
         * @param data the data to pack into a setting bitfield
         * @return 48-bit data field of settings in the wire format
         */
        inline uint64_t constructColorExtraFrameMode(uint8_t data) {
            return redux::canand::utils::packUInt(data, 8, 0);
        }

        /** 
         * Unpack setting COLOR_EXTRA_FRAME_MODE from the wire format.
         * @param data the 48-bit data field to extract a setting struct from.
         * @return a setting struct
         */
        inline uint8_t extractColorExtraFrameMode(uint64_t data) {
            return redux::canand::utils::extractU8(data, 8, 0);
        }

        /** 
         * Construct setting LAMP_BRIGHTNESS 
         * @param data the data to pack into a setting bitfield
         * @return 48-bit data field of settings in the wire format
         */
        inline uint64_t constructLampBrightness(uint16_t data) {
            return redux::canand::utils::packUInt(data, 16, 0);
        }

        /** 
         * Unpack setting LAMP_BRIGHTNESS from the wire format.
         * @param data the 48-bit data field to extract a setting struct from.
         * @return a setting struct
         */
        inline uint16_t extractLampBrightness(uint64_t data) {
            return redux::canand::utils::extractU16(data, 16, 0);
        }

        /** 
         * Construct setting COLOR_INTEGRATION_PERIOD 
         * @param data the data to pack into a setting bitfield
         * @return 48-bit data field of settings in the wire format
         */
        inline uint64_t constructColorIntegrationPeriod(uint8_t data) {
            return redux::canand::utils::packUInt(data, 4, 0);
        }

        /** 
         * Unpack setting COLOR_INTEGRATION_PERIOD from the wire format.
         * @param data the 48-bit data field to extract a setting struct from.
         * @return a setting struct
         */
        inline uint8_t extractColorIntegrationPeriod(uint64_t data) {
            return redux::canand::utils::extractU8(data, 4, 0);
        }

        /** 
         * Construct setting DISTANCE_INTEGRATION_PERIOD 
         * @param data the data to pack into a setting bitfield
         * @return 48-bit data field of settings in the wire format
         */
        inline uint64_t constructDistanceIntegrationPeriod(uint8_t data) {
            return redux::canand::utils::packUInt(data, 4, 0);
        }

        /** 
         * Unpack setting DISTANCE_INTEGRATION_PERIOD from the wire format.
         * @param data the 48-bit data field to extract a setting struct from.
         * @return a setting struct
         */
        inline uint8_t extractDistanceIntegrationPeriod(uint64_t data) {
            return redux::canand::utils::extractU8(data, 4, 0);
        }

        /** 
         * Construct setting DIGOUT1_OUTPUT_CONFIG 
         * @param data the data to pack into a setting bitfield
         * @return 48-bit data field of settings in the wire format
         */
        inline uint64_t constructDigout1OutputConfig(types::DigoutControlConfig data) {
            return (data.encode() << 0);
        }

        /** 
         * Unpack setting DIGOUT1_OUTPUT_CONFIG from the wire format.
         * @param data the 48-bit data field to extract a setting struct from.
         * @return a setting struct
         */
        inline types::DigoutControlConfig extractDigout1OutputConfig(uint64_t data) {
            return types::DigoutControlConfig::decode(data >> 0);
        }

        /** 
         * Construct setting DIGOUT2_OUTPUT_CONFIG 
         * @param data the data to pack into a setting bitfield
         * @return 48-bit data field of settings in the wire format
         */
        inline uint64_t constructDigout2OutputConfig(types::DigoutControlConfig data) {
            return (data.encode() << 0);
        }

        /** 
         * Unpack setting DIGOUT2_OUTPUT_CONFIG from the wire format.
         * @param data the 48-bit data field to extract a setting struct from.
         * @return a setting struct
         */
        inline types::DigoutControlConfig extractDigout2OutputConfig(uint64_t data) {
            return types::DigoutControlConfig::decode(data >> 0);
        }

        /** 
         * Construct setting DIGOUT1_MESSAGE_ON_CHANGE 
         * @param data the data to pack into a setting bitfield
         * @return 48-bit data field of settings in the wire format
         */
        inline uint64_t constructDigout1MessageOnChange(types::DigoutMessageTrigger data) {
            return (data.encode() << 0);
        }

        /** 
         * Unpack setting DIGOUT1_MESSAGE_ON_CHANGE from the wire format.
         * @param data the 48-bit data field to extract a setting struct from.
         * @return a setting struct
         */
        inline types::DigoutMessageTrigger extractDigout1MessageOnChange(uint64_t data) {
            return types::DigoutMessageTrigger::decode(data >> 0);
        }

        /** 
         * Construct setting DIGOUT2_MESSAGE_ON_CHANGE 
         * @param data the data to pack into a setting bitfield
         * @return 48-bit data field of settings in the wire format
         */
        inline uint64_t constructDigout2MessageOnChange(types::DigoutMessageTrigger data) {
            return (data.encode() << 0);
        }

        /** 
         * Unpack setting DIGOUT2_MESSAGE_ON_CHANGE from the wire format.
         * @param data the 48-bit data field to extract a setting struct from.
         * @return a setting struct
         */
        inline types::DigoutMessageTrigger extractDigout2MessageOnChange(uint64_t data) {
            return types::DigoutMessageTrigger::decode(data >> 0);
        }

        /** 
         * Construct setting DIGOUT1_CONFIG_0 
         * @param data the data to pack into a setting bitfield
         * @return 48-bit data field of settings in the wire format
         */
        inline uint64_t constructDigout1Config0(types::DigoutSlot data) {
            return (data.encode() << 0);
        }

        /** 
         * Unpack setting DIGOUT1_CONFIG_0 from the wire format.
         * @param data the 48-bit data field to extract a setting struct from.
         * @return a setting struct
         */
        inline types::DigoutSlot extractDigout1Config0(uint64_t data) {
            return types::DigoutSlot::decode(data >> 0);
        }

        /** 
         * Construct setting DIGOUT1_CONFIG_1 
         * @param data the data to pack into a setting bitfield
         * @return 48-bit data field of settings in the wire format
         */
        inline uint64_t constructDigout1Config1(types::DigoutSlot data) {
            return (data.encode() << 0);
        }

        /** 
         * Unpack setting DIGOUT1_CONFIG_1 from the wire format.
         * @param data the 48-bit data field to extract a setting struct from.
         * @return a setting struct
         */
        inline types::DigoutSlot extractDigout1Config1(uint64_t data) {
            return types::DigoutSlot::decode(data >> 0);
        }

        /** 
         * Construct setting DIGOUT1_CONFIG_2 
         * @param data the data to pack into a setting bitfield
         * @return 48-bit data field of settings in the wire format
         */
        inline uint64_t constructDigout1Config2(types::DigoutSlot data) {
            return (data.encode() << 0);
        }

        /** 
         * Unpack setting DIGOUT1_CONFIG_2 from the wire format.
         * @param data the 48-bit data field to extract a setting struct from.
         * @return a setting struct
         */
        inline types::DigoutSlot extractDigout1Config2(uint64_t data) {
            return types::DigoutSlot::decode(data >> 0);
        }

        /** 
         * Construct setting DIGOUT1_CONFIG_3 
         * @param data the data to pack into a setting bitfield
         * @return 48-bit data field of settings in the wire format
         */
        inline uint64_t constructDigout1Config3(types::DigoutSlot data) {
            return (data.encode() << 0);
        }

        /** 
         * Unpack setting DIGOUT1_CONFIG_3 from the wire format.
         * @param data the 48-bit data field to extract a setting struct from.
         * @return a setting struct
         */
        inline types::DigoutSlot extractDigout1Config3(uint64_t data) {
            return types::DigoutSlot::decode(data >> 0);
        }

        /** 
         * Construct setting DIGOUT1_CONFIG_4 
         * @param data the data to pack into a setting bitfield
         * @return 48-bit data field of settings in the wire format
         */
        inline uint64_t constructDigout1Config4(types::DigoutSlot data) {
            return (data.encode() << 0);
        }

        /** 
         * Unpack setting DIGOUT1_CONFIG_4 from the wire format.
         * @param data the 48-bit data field to extract a setting struct from.
         * @return a setting struct
         */
        inline types::DigoutSlot extractDigout1Config4(uint64_t data) {
            return types::DigoutSlot::decode(data >> 0);
        }

        /** 
         * Construct setting DIGOUT1_CONFIG_5 
         * @param data the data to pack into a setting bitfield
         * @return 48-bit data field of settings in the wire format
         */
        inline uint64_t constructDigout1Config5(types::DigoutSlot data) {
            return (data.encode() << 0);
        }

        /** 
         * Unpack setting DIGOUT1_CONFIG_5 from the wire format.
         * @param data the 48-bit data field to extract a setting struct from.
         * @return a setting struct
         */
        inline types::DigoutSlot extractDigout1Config5(uint64_t data) {
            return types::DigoutSlot::decode(data >> 0);
        }

        /** 
         * Construct setting DIGOUT1_CONFIG_6 
         * @param data the data to pack into a setting bitfield
         * @return 48-bit data field of settings in the wire format
         */
        inline uint64_t constructDigout1Config6(types::DigoutSlot data) {
            return (data.encode() << 0);
        }

        /** 
         * Unpack setting DIGOUT1_CONFIG_6 from the wire format.
         * @param data the 48-bit data field to extract a setting struct from.
         * @return a setting struct
         */
        inline types::DigoutSlot extractDigout1Config6(uint64_t data) {
            return types::DigoutSlot::decode(data >> 0);
        }

        /** 
         * Construct setting DIGOUT1_CONFIG_7 
         * @param data the data to pack into a setting bitfield
         * @return 48-bit data field of settings in the wire format
         */
        inline uint64_t constructDigout1Config7(types::DigoutSlot data) {
            return (data.encode() << 0);
        }

        /** 
         * Unpack setting DIGOUT1_CONFIG_7 from the wire format.
         * @param data the 48-bit data field to extract a setting struct from.
         * @return a setting struct
         */
        inline types::DigoutSlot extractDigout1Config7(uint64_t data) {
            return types::DigoutSlot::decode(data >> 0);
        }

        /** 
         * Construct setting DIGOUT1_CONFIG_8 
         * @param data the data to pack into a setting bitfield
         * @return 48-bit data field of settings in the wire format
         */
        inline uint64_t constructDigout1Config8(types::DigoutSlot data) {
            return (data.encode() << 0);
        }

        /** 
         * Unpack setting DIGOUT1_CONFIG_8 from the wire format.
         * @param data the 48-bit data field to extract a setting struct from.
         * @return a setting struct
         */
        inline types::DigoutSlot extractDigout1Config8(uint64_t data) {
            return types::DigoutSlot::decode(data >> 0);
        }

        /** 
         * Construct setting DIGOUT1_CONFIG_9 
         * @param data the data to pack into a setting bitfield
         * @return 48-bit data field of settings in the wire format
         */
        inline uint64_t constructDigout1Config9(types::DigoutSlot data) {
            return (data.encode() << 0);
        }

        /** 
         * Unpack setting DIGOUT1_CONFIG_9 from the wire format.
         * @param data the 48-bit data field to extract a setting struct from.
         * @return a setting struct
         */
        inline types::DigoutSlot extractDigout1Config9(uint64_t data) {
            return types::DigoutSlot::decode(data >> 0);
        }

        /** 
         * Construct setting DIGOUT1_CONFIG_10 
         * @param data the data to pack into a setting bitfield
         * @return 48-bit data field of settings in the wire format
         */
        inline uint64_t constructDigout1Config10(types::DigoutSlot data) {
            return (data.encode() << 0);
        }

        /** 
         * Unpack setting DIGOUT1_CONFIG_10 from the wire format.
         * @param data the 48-bit data field to extract a setting struct from.
         * @return a setting struct
         */
        inline types::DigoutSlot extractDigout1Config10(uint64_t data) {
            return types::DigoutSlot::decode(data >> 0);
        }

        /** 
         * Construct setting DIGOUT1_CONFIG_11 
         * @param data the data to pack into a setting bitfield
         * @return 48-bit data field of settings in the wire format
         */
        inline uint64_t constructDigout1Config11(types::DigoutSlot data) {
            return (data.encode() << 0);
        }

        /** 
         * Unpack setting DIGOUT1_CONFIG_11 from the wire format.
         * @param data the 48-bit data field to extract a setting struct from.
         * @return a setting struct
         */
        inline types::DigoutSlot extractDigout1Config11(uint64_t data) {
            return types::DigoutSlot::decode(data >> 0);
        }

        /** 
         * Construct setting DIGOUT1_CONFIG_12 
         * @param data the data to pack into a setting bitfield
         * @return 48-bit data field of settings in the wire format
         */
        inline uint64_t constructDigout1Config12(types::DigoutSlot data) {
            return (data.encode() << 0);
        }

        /** 
         * Unpack setting DIGOUT1_CONFIG_12 from the wire format.
         * @param data the 48-bit data field to extract a setting struct from.
         * @return a setting struct
         */
        inline types::DigoutSlot extractDigout1Config12(uint64_t data) {
            return types::DigoutSlot::decode(data >> 0);
        }

        /** 
         * Construct setting DIGOUT1_CONFIG_13 
         * @param data the data to pack into a setting bitfield
         * @return 48-bit data field of settings in the wire format
         */
        inline uint64_t constructDigout1Config13(types::DigoutSlot data) {
            return (data.encode() << 0);
        }

        /** 
         * Unpack setting DIGOUT1_CONFIG_13 from the wire format.
         * @param data the 48-bit data field to extract a setting struct from.
         * @return a setting struct
         */
        inline types::DigoutSlot extractDigout1Config13(uint64_t data) {
            return types::DigoutSlot::decode(data >> 0);
        }

        /** 
         * Construct setting DIGOUT1_CONFIG_14 
         * @param data the data to pack into a setting bitfield
         * @return 48-bit data field of settings in the wire format
         */
        inline uint64_t constructDigout1Config14(types::DigoutSlot data) {
            return (data.encode() << 0);
        }

        /** 
         * Unpack setting DIGOUT1_CONFIG_14 from the wire format.
         * @param data the 48-bit data field to extract a setting struct from.
         * @return a setting struct
         */
        inline types::DigoutSlot extractDigout1Config14(uint64_t data) {
            return types::DigoutSlot::decode(data >> 0);
        }

        /** 
         * Construct setting DIGOUT1_CONFIG_15 
         * @param data the data to pack into a setting bitfield
         * @return 48-bit data field of settings in the wire format
         */
        inline uint64_t constructDigout1Config15(types::DigoutSlot data) {
            return (data.encode() << 0);
        }

        /** 
         * Unpack setting DIGOUT1_CONFIG_15 from the wire format.
         * @param data the 48-bit data field to extract a setting struct from.
         * @return a setting struct
         */
        inline types::DigoutSlot extractDigout1Config15(uint64_t data) {
            return types::DigoutSlot::decode(data >> 0);
        }

        /** 
         * Construct setting DIGOUT2_CONFIG_0 
         * @param data the data to pack into a setting bitfield
         * @return 48-bit data field of settings in the wire format
         */
        inline uint64_t constructDigout2Config0(types::DigoutSlot data) {
            return (data.encode() << 0);
        }

        /** 
         * Unpack setting DIGOUT2_CONFIG_0 from the wire format.
         * @param data the 48-bit data field to extract a setting struct from.
         * @return a setting struct
         */
        inline types::DigoutSlot extractDigout2Config0(uint64_t data) {
            return types::DigoutSlot::decode(data >> 0);
        }

        /** 
         * Construct setting DIGOUT2_CONFIG_1 
         * @param data the data to pack into a setting bitfield
         * @return 48-bit data field of settings in the wire format
         */
        inline uint64_t constructDigout2Config1(types::DigoutSlot data) {
            return (data.encode() << 0);
        }

        /** 
         * Unpack setting DIGOUT2_CONFIG_1 from the wire format.
         * @param data the 48-bit data field to extract a setting struct from.
         * @return a setting struct
         */
        inline types::DigoutSlot extractDigout2Config1(uint64_t data) {
            return types::DigoutSlot::decode(data >> 0);
        }

        /** 
         * Construct setting DIGOUT2_CONFIG_2 
         * @param data the data to pack into a setting bitfield
         * @return 48-bit data field of settings in the wire format
         */
        inline uint64_t constructDigout2Config2(types::DigoutSlot data) {
            return (data.encode() << 0);
        }

        /** 
         * Unpack setting DIGOUT2_CONFIG_2 from the wire format.
         * @param data the 48-bit data field to extract a setting struct from.
         * @return a setting struct
         */
        inline types::DigoutSlot extractDigout2Config2(uint64_t data) {
            return types::DigoutSlot::decode(data >> 0);
        }

        /** 
         * Construct setting DIGOUT2_CONFIG_3 
         * @param data the data to pack into a setting bitfield
         * @return 48-bit data field of settings in the wire format
         */
        inline uint64_t constructDigout2Config3(types::DigoutSlot data) {
            return (data.encode() << 0);
        }

        /** 
         * Unpack setting DIGOUT2_CONFIG_3 from the wire format.
         * @param data the 48-bit data field to extract a setting struct from.
         * @return a setting struct
         */
        inline types::DigoutSlot extractDigout2Config3(uint64_t data) {
            return types::DigoutSlot::decode(data >> 0);
        }

        /** 
         * Construct setting DIGOUT2_CONFIG_4 
         * @param data the data to pack into a setting bitfield
         * @return 48-bit data field of settings in the wire format
         */
        inline uint64_t constructDigout2Config4(types::DigoutSlot data) {
            return (data.encode() << 0);
        }

        /** 
         * Unpack setting DIGOUT2_CONFIG_4 from the wire format.
         * @param data the 48-bit data field to extract a setting struct from.
         * @return a setting struct
         */
        inline types::DigoutSlot extractDigout2Config4(uint64_t data) {
            return types::DigoutSlot::decode(data >> 0);
        }

        /** 
         * Construct setting DIGOUT2_CONFIG_5 
         * @param data the data to pack into a setting bitfield
         * @return 48-bit data field of settings in the wire format
         */
        inline uint64_t constructDigout2Config5(types::DigoutSlot data) {
            return (data.encode() << 0);
        }

        /** 
         * Unpack setting DIGOUT2_CONFIG_5 from the wire format.
         * @param data the 48-bit data field to extract a setting struct from.
         * @return a setting struct
         */
        inline types::DigoutSlot extractDigout2Config5(uint64_t data) {
            return types::DigoutSlot::decode(data >> 0);
        }

        /** 
         * Construct setting DIGOUT2_CONFIG_6 
         * @param data the data to pack into a setting bitfield
         * @return 48-bit data field of settings in the wire format
         */
        inline uint64_t constructDigout2Config6(types::DigoutSlot data) {
            return (data.encode() << 0);
        }

        /** 
         * Unpack setting DIGOUT2_CONFIG_6 from the wire format.
         * @param data the 48-bit data field to extract a setting struct from.
         * @return a setting struct
         */
        inline types::DigoutSlot extractDigout2Config6(uint64_t data) {
            return types::DigoutSlot::decode(data >> 0);
        }

        /** 
         * Construct setting DIGOUT2_CONFIG_7 
         * @param data the data to pack into a setting bitfield
         * @return 48-bit data field of settings in the wire format
         */
        inline uint64_t constructDigout2Config7(types::DigoutSlot data) {
            return (data.encode() << 0);
        }

        /** 
         * Unpack setting DIGOUT2_CONFIG_7 from the wire format.
         * @param data the 48-bit data field to extract a setting struct from.
         * @return a setting struct
         */
        inline types::DigoutSlot extractDigout2Config7(uint64_t data) {
            return types::DigoutSlot::decode(data >> 0);
        }

        /** 
         * Construct setting DIGOUT2_CONFIG_8 
         * @param data the data to pack into a setting bitfield
         * @return 48-bit data field of settings in the wire format
         */
        inline uint64_t constructDigout2Config8(types::DigoutSlot data) {
            return (data.encode() << 0);
        }

        /** 
         * Unpack setting DIGOUT2_CONFIG_8 from the wire format.
         * @param data the 48-bit data field to extract a setting struct from.
         * @return a setting struct
         */
        inline types::DigoutSlot extractDigout2Config8(uint64_t data) {
            return types::DigoutSlot::decode(data >> 0);
        }

        /** 
         * Construct setting DIGOUT2_CONFIG_9 
         * @param data the data to pack into a setting bitfield
         * @return 48-bit data field of settings in the wire format
         */
        inline uint64_t constructDigout2Config9(types::DigoutSlot data) {
            return (data.encode() << 0);
        }

        /** 
         * Unpack setting DIGOUT2_CONFIG_9 from the wire format.
         * @param data the 48-bit data field to extract a setting struct from.
         * @return a setting struct
         */
        inline types::DigoutSlot extractDigout2Config9(uint64_t data) {
            return types::DigoutSlot::decode(data >> 0);
        }

        /** 
         * Construct setting DIGOUT2_CONFIG_10 
         * @param data the data to pack into a setting bitfield
         * @return 48-bit data field of settings in the wire format
         */
        inline uint64_t constructDigout2Config10(types::DigoutSlot data) {
            return (data.encode() << 0);
        }

        /** 
         * Unpack setting DIGOUT2_CONFIG_10 from the wire format.
         * @param data the 48-bit data field to extract a setting struct from.
         * @return a setting struct
         */
        inline types::DigoutSlot extractDigout2Config10(uint64_t data) {
            return types::DigoutSlot::decode(data >> 0);
        }

        /** 
         * Construct setting DIGOUT2_CONFIG_11 
         * @param data the data to pack into a setting bitfield
         * @return 48-bit data field of settings in the wire format
         */
        inline uint64_t constructDigout2Config11(types::DigoutSlot data) {
            return (data.encode() << 0);
        }

        /** 
         * Unpack setting DIGOUT2_CONFIG_11 from the wire format.
         * @param data the 48-bit data field to extract a setting struct from.
         * @return a setting struct
         */
        inline types::DigoutSlot extractDigout2Config11(uint64_t data) {
            return types::DigoutSlot::decode(data >> 0);
        }

        /** 
         * Construct setting DIGOUT2_CONFIG_12 
         * @param data the data to pack into a setting bitfield
         * @return 48-bit data field of settings in the wire format
         */
        inline uint64_t constructDigout2Config12(types::DigoutSlot data) {
            return (data.encode() << 0);
        }

        /** 
         * Unpack setting DIGOUT2_CONFIG_12 from the wire format.
         * @param data the 48-bit data field to extract a setting struct from.
         * @return a setting struct
         */
        inline types::DigoutSlot extractDigout2Config12(uint64_t data) {
            return types::DigoutSlot::decode(data >> 0);
        }

        /** 
         * Construct setting DIGOUT2_CONFIG_13 
         * @param data the data to pack into a setting bitfield
         * @return 48-bit data field of settings in the wire format
         */
        inline uint64_t constructDigout2Config13(types::DigoutSlot data) {
            return (data.encode() << 0);
        }

        /** 
         * Unpack setting DIGOUT2_CONFIG_13 from the wire format.
         * @param data the 48-bit data field to extract a setting struct from.
         * @return a setting struct
         */
        inline types::DigoutSlot extractDigout2Config13(uint64_t data) {
            return types::DigoutSlot::decode(data >> 0);
        }

        /** 
         * Construct setting DIGOUT2_CONFIG_14 
         * @param data the data to pack into a setting bitfield
         * @return 48-bit data field of settings in the wire format
         */
        inline uint64_t constructDigout2Config14(types::DigoutSlot data) {
            return (data.encode() << 0);
        }

        /** 
         * Unpack setting DIGOUT2_CONFIG_14 from the wire format.
         * @param data the 48-bit data field to extract a setting struct from.
         * @return a setting struct
         */
        inline types::DigoutSlot extractDigout2Config14(uint64_t data) {
            return types::DigoutSlot::decode(data >> 0);
        }

        /** 
         * Construct setting DIGOUT2_CONFIG_15 
         * @param data the data to pack into a setting bitfield
         * @return 48-bit data field of settings in the wire format
         */
        inline uint64_t constructDigout2Config15(types::DigoutSlot data) {
            return (data.encode() << 0);
        }

        /** 
         * Unpack setting DIGOUT2_CONFIG_15 from the wire format.
         * @param data the 48-bit data field to extract a setting struct from.
         * @return a setting struct
         */
        inline types::DigoutSlot extractDigout2Config15(uint64_t data) {
            return types::DigoutSlot::decode(data >> 0);
        }


        /**
         * Settings that are required for the vdep to flag all values as received.
         */
        const std::vector<uint8_t> VDEP_SETTINGS = {
            kStatusFramePeriod,
            kScratch0,
            kScratch1,
            kDistanceFramePeriod,
            kColorFramePeriod,
            kDigoutFramePeriod,
            kDistanceExtraFrameMode,
            kColorExtraFrameMode,
            kLampBrightness,
            kColorIntegrationPeriod,
            kDistanceIntegrationPeriod,
            kDigout1OutputConfig,
            kDigout2OutputConfig,
            kDigout1MessageOnChange,
            kDigout2MessageOnChange,
        };

    }
}
