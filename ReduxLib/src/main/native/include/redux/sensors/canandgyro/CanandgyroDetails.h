// Copyright (c) Bagholders of Redux Robotics and other contributors.
// This is open source and can be modified and shared under the Mozilla Public License v2.0. 

#pragma once
#include <cinttypes>
#include <vector>
#include <cstring>
#include "redux/canand/CanandUtils.h"
#include "redux/canand/CanandAddress.h"

/**
 * Canandgyro protocol-level definitions.
 * 
 * This file is autogenerated by canandmessage, <b>do not hand-edit!</b>
 */
namespace redux::sensors::canandgyro::details {

    /** Types. */
    namespace types {
        /** SettingReportFlags bitset definition */
        class SettingReportFlags {
          public:
            enum : uint8_t {
                /** Whether the setting set/fetch was successful */
                kSetSuccess = 1 << 0,

                /** Whether the setting synch commit was successful */
                kCommitSuccess = 1 << 1,

            };
        };

        /** Faults bitset definition */
        class Faults {
          public:
            enum : uint8_t {
                /** The power cycle fault flag, which is set to true when the device first boots.
                Clearing sticky faults and then checking this flag can be used to determine if the device rebooted.
                 */
                kPowerCycle = 1 << 0,

                /** The CAN ID conflict flag, which is set to true if there is a CAN id conflict.
                In practice, you should physically inspect the device to ensure it's not flashing blue.
                 */
                kCanIdConflict = 1 << 1,

                /** The CAN general error flag, which will raise if the device encounters a CAN fault during operation.
                If communication with the device still functions, this will not register as an active fault for long if at all.
                This may raise due to wiring issues, such as an intermittently shorted CAN bus.
                 */
                kCanGeneralError = 1 << 2,

                /** The temperature range flag, which will raise if the device is not between 0-70 degrees Celsius.
                This may be of concern if the device is near very active motors.
                 */
                kOutOfTemperatureRange = 1 << 3,

                /** The hardware fault flag, which will raise if a hardware issue is detected.
                Generally will raise if the device's controller cannot read the physical sensor itself.
                 */
                kHardwareFault = 1 << 4,

                /** The calibration status flag, which will raise if the device is currently calibrating.
                 */
                kCalibrating = 1 << 5,

                /** The angular velocity saturation flag, which triggers on saturation of angular velocity.
                 */
                kAngularVelocitySaturation = 1 << 6,

                /** The acceleration saturation flag, which triggers on saturation of acceleration.
                 */
                kAccelerationSaturation = 1 << 7,

            };
        };

        /** CALIBRATION_TYPE enum definition */
        class CalibrationType {
          public:
            enum : uint8_t {
                /** Normal calibration routine */
                kNormal = 0x0,

                /** Save ZRO at calibration complete */
                kSaveZro = 0x1,

                /** Temperature calibrate slot 0 */
                kTempCal0 = 0x2,

                /** Temperature calibrate slot 1 */
                kTempCal1 = 0x3,

            };
        };

        /** SETTING_COMMAND enum definition */
        class SettingCommand {
          public:
            enum : uint8_t {
                /** Fetch all settings from device via a series of :ref:`report setting<msg_report_setting>` messages of all indexes */
                kFetchSettings = 0x0,

                /** Reset all resettanble settings to factory default, and broadcast all setting values via
                :ref:`report setting<msg_report_setting>` messages.
                 */
                kResetFactoryDefault = 0x1,

                /** Requests to fetch a single setting from device, with its value reported via the 
                :ref:`report setting<msg_report_setting>` message. 

                This requires the use of the second byte to specify the setting index to fetch. */
                kFetchSettingValue = 0x2,

            };
        };

        /** setting_flags definition */
        struct SettingFlags {
          public:
            /** Whether the setting should be set ephemeral */
            bool ephemeral;

            /** Whether the setting should be held until the next synch barrier */
            bool synch_hold;

            /** Synch message count */
            uint8_t synch_msg_count;

            /**
             * Decodes a struct.
             * 
             * @param data intfield to decode
             * @return a decoded struct
             */
            static constexpr SettingFlags decode(uint64_t data) {
                return SettingFlags {
                    .ephemeral = redux::canand::utils::extractBool(data, 0),
                    .synch_hold = redux::canand::utils::extractBool(data, 1),
                    .synch_msg_count = redux::canand::utils::extractU8(data, 4, 4),  
                };
            }

            /**
             * Encodes a struct.
             *
             * @return an encoded struct.
             */
            constexpr uint64_t encode() {
                return (
                    0 |
                    redux::canand::utils::packBool(this->ephemeral, 0) |
                    redux::canand::utils::packBool(this->synch_hold, 1) |
                    redux::canand::utils::packUInt(this->synch_msg_count, 4, 4) 
                );
            }


        };

        /** firmware_version definition */
        struct FirmwareVersion {
          public:
            /** Firmware version patch number */
            uint8_t firmware_patch;

            /** Firmware version minor number */
            uint8_t firmware_minor;

            /** Firmware version year */
            uint16_t firmware_year;

            /**
             * Decodes a struct.
             * 
             * @param data intfield to decode
             * @return a decoded struct
             */
            static constexpr FirmwareVersion decode(uint64_t data) {
                return FirmwareVersion {
                    .firmware_patch = redux::canand::utils::extractU8(data, 8, 0),
                    .firmware_minor = redux::canand::utils::extractU8(data, 8, 8),
                    .firmware_year = redux::canand::utils::extractU16(data, 16, 16),  
                };
            }

            /**
             * Encodes a struct.
             *
             * @return an encoded struct.
             */
            constexpr uint64_t encode() {
                return (
                    0 |
                    redux::canand::utils::packUInt(this->firmware_patch, 8, 0) |
                    redux::canand::utils::packUInt(this->firmware_minor, 8, 8) |
                    redux::canand::utils::packUInt(this->firmware_year, 16, 16) 
                );
            }


        };

        /** temp_cal_point definition */
        struct TempCalPoint {
          public:
            /** Temperature point */
            int16_t temperature_point;

            /** Offset at the temperature */
            float offset;

            /**
             * Decodes a struct.
             * 
             * @param data intfield to decode
             * @return a decoded struct
             */
            static constexpr TempCalPoint decode(uint64_t data) {
                return TempCalPoint {
                    .temperature_point = redux::canand::utils::extractI16(data, 16, 0),
                    .offset = redux::canand::utils::extractF32(data, 16),  
                };
            }

            /**
             * Encodes a struct.
             *
             * @return an encoded struct.
             */
            constexpr uint64_t encode() {
                return (
                    0 |
                    redux::canand::utils::packInt(this->temperature_point, 16, 0) |
                    redux::canand::utils::packF32(this->offset, 16) 
                );
            }


        };

        /** quat_xyz definition */
        struct QuatXyz {
          public:
            /** Quaternion x term */
            int16_t x;

            /** Quaternion y term */
            int16_t y;

            /** Quaternion z term */
            int16_t z;

            /**
             * Decodes a struct.
             * 
             * @param data intfield to decode
             * @return a decoded struct
             */
            static constexpr QuatXyz decode(uint64_t data) {
                return QuatXyz {
                    .x = redux::canand::utils::extractI16(data, 16, 0),
                    .y = redux::canand::utils::extractI16(data, 16, 16),
                    .z = redux::canand::utils::extractI16(data, 16, 32),  
                };
            }

            /**
             * Encodes a struct.
             *
             * @return an encoded struct.
             */
            constexpr uint64_t encode() {
                return (
                    0 |
                    redux::canand::utils::packInt(this->x, 16, 0) |
                    redux::canand::utils::packInt(this->y, 16, 16) |
                    redux::canand::utils::packInt(this->z, 16, 32) 
                );
            }


        };

        /** yaw definition */
        struct Yaw {
          public:
            /** Yaw angle (f32 between [-pi..pi) radians) */
            float yaw;

            /** Wraparound counter */
            int16_t wraparound;

            /**
             * Decodes a struct.
             * 
             * @param data intfield to decode
             * @return a decoded struct
             */
            static constexpr Yaw decode(uint64_t data) {
                return Yaw {
                    .yaw = redux::canand::utils::extractF32(data, 0),
                    .wraparound = redux::canand::utils::extractI16(data, 16, 32),  
                };
            }

            /**
             * Encodes a struct.
             *
             * @return an encoded struct.
             */
            constexpr uint64_t encode() {
                return (
                    0 |
                    redux::canand::utils::packF32(this->yaw, 0) |
                    redux::canand::utils::packInt(this->wraparound, 16, 32) 
                );
            }


        };

    }

    /** Messages. */
    namespace msg {
        enum : uint8_t {
            /** setting control command */
            kSettingCommand = 0x2,

            /** update setting on device */
            kSetSetting = 0x3,

            /** setting value report from device */
            kReportSetting = 0x4,

            /** Clear device sticky faults */
            kClearStickyFaults = 0x5,

            /** Status frame */
            kStatus = 0x6,

            /** Party mode */
            kPartyMode = 0x7,

            /** Device enumerate response */
            kEnumerate = 0xb,

            /** Yaw angle frame */
            kYawOutput = 0x1f,

            /** Angular position quaternion frame */
            kAngularPositionOutput = 0x1e,

            /** Angular velocity frame */
            kAngularVelocityOutput = 0x1d,

            /** Acceleration frame */
            kAccelerationOutput = 0x1c,

            /** Trigger Calibration */
            kCalibrate = 0x1b,

            /** Calibration Status */
            kCalibrationStatus = 0x1a,

        };
        /** setting control command struct */
        struct SettingCommand {
          public:
            /** Setting command index */
            uint8_t control_flag;

            /** setting index to fetch */
            uint8_t setting_index;

            /**
             * Decodes a struct.
             * 
             * @param data intfield to decode
             * @return a decoded struct
             */
            static constexpr SettingCommand decode(uint64_t data) {
                return SettingCommand {
                    .control_flag = redux::canand::utils::extractU8(data, 8, 0),
                    .setting_index = redux::canand::utils::extractU8(data, 8, 8),  
                };
            }

            /**
             * Encodes a struct.
             *
             * @return an encoded struct.
             */
            constexpr uint64_t encode() {
                return (
                    0 |
                    redux::canand::utils::packUInt(this->control_flag, 8, 0) |
                    redux::canand::utils::packUInt(this->setting_index, 8, 8) 
                );
            }


            /** Minimum acceptable data length code for this message */
            static const uint32_t DLC_MIN = 1;

            /** Maximum acceptable data length code for this message */
            static const uint32_t DLC_MAX = 8;

            /**
             * Sends the message struct to a CanandAddress.
             * @param addr the address to send to
             * @return the return value of SendCANMessage
             */
            inline bool send(redux::canand::CanandAddress& addr) {
                uint64_t data = this->encode();
                return addr.SendCANMessage(msg::kSettingCommand, (uint8_t*) &data, 8);
            }

        };

        /** update setting on device struct */
        struct SetSetting {
          public:
            /** Setting index to write to */
            uint8_t address;

            /** 6-byte setting value */
            uint64_t value;

            /** Setting flags */
            types::SettingFlags flags;

            /**
             * Decodes a struct.
             * 
             * @param data intfield to decode
             * @return a decoded struct
             */
            static constexpr SetSetting decode(uint64_t data) {
                return SetSetting {
                    .address = redux::canand::utils::extractU8(data, 8, 0),
                    .value = redux::canand::utils::extractU64(data, 48, 8),
                    .flags = types::SettingFlags::decode(data >> 56),  
                };
            }

            /**
             * Encodes a struct.
             *
             * @return an encoded struct.
             */
            constexpr uint64_t encode() {
                return (
                    0 |
                    redux::canand::utils::packUInt(this->address, 8, 0) |
                    redux::canand::utils::packUInt(this->value, 48, 8) |
                    (this->flags.encode() << 56) 
                );
            }


            /** Minimum acceptable data length code for this message */
            static const uint32_t DLC_MIN = 8;

            /** Maximum acceptable data length code for this message */
            static const uint32_t DLC_MAX = 8;

            /**
             * Sends the message struct to a CanandAddress.
             * @param addr the address to send to
             * @return the return value of SendCANMessage
             */
            inline bool send(redux::canand::CanandAddress& addr) {
                uint64_t data = this->encode();
                return addr.SendCANMessage(msg::kSetSetting, (uint8_t*) &data, 8);
            }

        };

        /** setting value report from device struct */
        struct ReportSetting {
          public:
            /** Setting index to write to */
            uint8_t address;

            /** 6-byte setting value */
            uint64_t value;

            /** Setting receive status */
            uint8_t flags;

            /**
             * Decodes a struct.
             * 
             * @param data intfield to decode
             * @return a decoded struct
             */
            static constexpr ReportSetting decode(uint64_t data) {
                return ReportSetting {
                    .address = redux::canand::utils::extractU8(data, 8, 0),
                    .value = redux::canand::utils::extractU64(data, 48, 8),
                    .flags = redux::canand::utils::extractU8(data, 8, 56),  
                };
            }

            /**
             * Encodes a struct.
             *
             * @return an encoded struct.
             */
            constexpr uint64_t encode() {
                return (
                    0 |
                    redux::canand::utils::packUInt(this->address, 8, 0) |
                    redux::canand::utils::packUInt(this->value, 48, 8) |
                    redux::canand::utils::packUInt(this->flags, 8, 56) 
                );
            }


            /** Minimum acceptable data length code for this message */
            static const uint32_t DLC_MIN = 8;

            /** Maximum acceptable data length code for this message */
            static const uint32_t DLC_MAX = 8;

            /**
             * Sends the message struct to a CanandAddress.
             * @param addr the address to send to
             * @return the return value of SendCANMessage
             */
            inline bool send(redux::canand::CanandAddress& addr) {
                uint64_t data = this->encode();
                return addr.SendCANMessage(msg::kReportSetting, (uint8_t*) &data, 8);
            }

        };

        /** Clear device sticky faults struct */
        struct ClearStickyFaults {
          public:

            /**
             * Decodes a struct.
             * 
             * @param data intfield to decode
             * @return a decoded struct
             */
            static constexpr ClearStickyFaults decode(uint64_t data) {
                return ClearStickyFaults {
  
                };
            }

            /**
             * Encodes a struct.
             *
             * @return an encoded struct.
             */
            constexpr uint64_t encode() {
                return (
                    0 
                );
            }


            /** Minimum acceptable data length code for this message */
            static const uint32_t DLC_MIN = 0;

            /** Maximum acceptable data length code for this message */
            static const uint32_t DLC_MAX = 8;

            /**
             * Sends the message struct to a CanandAddress.
             * @param addr the address to send to
             * @return the return value of SendCANMessage
             */
            inline bool send(redux::canand::CanandAddress& addr) {
                uint64_t data = this->encode();
                return addr.SendCANMessage(msg::kClearStickyFaults, (uint8_t*) &data, 8);
            }

        };

        /** Status frame struct */
        struct Status {
          public:
            /** 8-bit active faults bitfield */
            uint8_t faults;

            /** 8-bit sticky faults bitfield */
            uint8_t sticky_faults;

            /** 16-bit signed temperature byte in 1/256ths of a Celsius */
            int16_t temperature;

            /**
             * Decodes a struct.
             * 
             * @param data intfield to decode
             * @return a decoded struct
             */
            static constexpr Status decode(uint64_t data) {
                return Status {
                    .faults = redux::canand::utils::extractU8(data, 8, 0),
                    .sticky_faults = redux::canand::utils::extractU8(data, 8, 8),
                    .temperature = redux::canand::utils::extractI16(data, 16, 16),  
                };
            }

            /**
             * Encodes a struct.
             *
             * @return an encoded struct.
             */
            constexpr uint64_t encode() {
                return (
                    0 |
                    redux::canand::utils::packUInt(this->faults, 8, 0) |
                    redux::canand::utils::packUInt(this->sticky_faults, 8, 8) |
                    redux::canand::utils::packInt(this->temperature, 16, 16) 
                );
            }


            /** Minimum acceptable data length code for this message */
            static const uint32_t DLC_MIN = 8;

            /** Maximum acceptable data length code for this message */
            static const uint32_t DLC_MAX = 8;

            /**
             * Sends the message struct to a CanandAddress.
             * @param addr the address to send to
             * @return the return value of SendCANMessage
             */
            inline bool send(redux::canand::CanandAddress& addr) {
                uint64_t data = this->encode();
                return addr.SendCANMessage(msg::kStatus, (uint8_t*) &data, 8);
            }

        };

        /** Party mode struct */
        struct PartyMode {
          public:
            /** Party level. 0 disables the strobe, whereas 1 enables it. */
            uint8_t party_level;

            /**
             * Decodes a struct.
             * 
             * @param data intfield to decode
             * @return a decoded struct
             */
            static constexpr PartyMode decode(uint64_t data) {
                return PartyMode {
                    .party_level = redux::canand::utils::extractU8(data, 8, 0),  
                };
            }

            /**
             * Encodes a struct.
             *
             * @return an encoded struct.
             */
            constexpr uint64_t encode() {
                return (
                    0 |
                    redux::canand::utils::packUInt(this->party_level, 8, 0) 
                );
            }


            /** Minimum acceptable data length code for this message */
            static const uint32_t DLC_MIN = 1;

            /** Maximum acceptable data length code for this message */
            static const uint32_t DLC_MAX = 8;

            /**
             * Sends the message struct to a CanandAddress.
             * @param addr the address to send to
             * @return the return value of SendCANMessage
             */
            inline bool send(redux::canand::CanandAddress& addr) {
                uint64_t data = this->encode();
                return addr.SendCANMessage(msg::kPartyMode, (uint8_t*) &data, 8);
            }

        };

        /** Device enumerate response struct */
        struct Enumerate {
          public:
            /** Device-unique serial number */
            uint64_t serial;

            /** Device is in bootloader. */
            bool is_bootloader;

            /**
             * Decodes a struct.
             * 
             * @param data intfield to decode
             * @return a decoded struct
             */
            static constexpr Enumerate decode(uint64_t data) {
                return Enumerate {
                    .serial = redux::canand::utils::extractU64(data, 48, 0),
                    .is_bootloader = redux::canand::utils::extractBool(data, 48),  
                };
            }

            /**
             * Encodes a struct.
             *
             * @return an encoded struct.
             */
            constexpr uint64_t encode() {
                return (
                    0 |
                    redux::canand::utils::packUInt(this->serial, 48, 0) |
                    redux::canand::utils::packBool(this->is_bootloader, 48) 
                );
            }


            /** Minimum acceptable data length code for this message */
            static const uint32_t DLC_MIN = 8;

            /** Maximum acceptable data length code for this message */
            static const uint32_t DLC_MAX = 8;

            /**
             * Sends the message struct to a CanandAddress.
             * @param addr the address to send to
             * @return the return value of SendCANMessage
             */
            inline bool send(redux::canand::CanandAddress& addr) {
                uint64_t data = this->encode();
                return addr.SendCANMessage(msg::kEnumerate, (uint8_t*) &data, 8);
            }

        };

        /** Yaw angle frame struct */
        struct YawOutput {
          public:
            /** Yaw value */
            types::Yaw yaw;

            /**
             * Decodes a struct.
             * 
             * @param data intfield to decode
             * @return a decoded struct
             */
            static constexpr YawOutput decode(uint64_t data) {
                return YawOutput {
                    .yaw = types::Yaw::decode(data >> 0),  
                };
            }

            /**
             * Encodes a struct.
             *
             * @return an encoded struct.
             */
            constexpr uint64_t encode() {
                return (
                    0 |
                    (this->yaw.encode() << 0) 
                );
            }


            /** Minimum acceptable data length code for this message */
            static const uint32_t DLC_MIN = 6;

            /** Maximum acceptable data length code for this message */
            static const uint32_t DLC_MAX = 6;

            /**
             * Sends the message struct to a CanandAddress.
             * @param addr the address to send to
             * @return the return value of SendCANMessage
             */
            inline bool send(redux::canand::CanandAddress& addr) {
                uint64_t data = this->encode();
                return addr.SendCANMessage(msg::kYawOutput, (uint8_t*) &data, 6);
            }

        };

        /** Angular position quaternion frame struct */
        struct AngularPositionOutput {
          public:
            /** Quaternion w term */
            int16_t w;

            /** Quaternion x term */
            int16_t x;

            /** Quaternion y term */
            int16_t y;

            /** Quaternion z term */
            int16_t z;

            /**
             * Decodes a struct.
             * 
             * @param data intfield to decode
             * @return a decoded struct
             */
            static constexpr AngularPositionOutput decode(uint64_t data) {
                return AngularPositionOutput {
                    .w = redux::canand::utils::extractI16(data, 16, 0),
                    .x = redux::canand::utils::extractI16(data, 16, 16),
                    .y = redux::canand::utils::extractI16(data, 16, 32),
                    .z = redux::canand::utils::extractI16(data, 16, 48),  
                };
            }

            /**
             * Encodes a struct.
             *
             * @return an encoded struct.
             */
            constexpr uint64_t encode() {
                return (
                    0 |
                    redux::canand::utils::packInt(this->w, 16, 0) |
                    redux::canand::utils::packInt(this->x, 16, 16) |
                    redux::canand::utils::packInt(this->y, 16, 32) |
                    redux::canand::utils::packInt(this->z, 16, 48) 
                );
            }


            /** Minimum acceptable data length code for this message */
            static const uint32_t DLC_MIN = 8;

            /** Maximum acceptable data length code for this message */
            static const uint32_t DLC_MAX = 8;

            /**
             * Sends the message struct to a CanandAddress.
             * @param addr the address to send to
             * @return the return value of SendCANMessage
             */
            inline bool send(redux::canand::CanandAddress& addr) {
                uint64_t data = this->encode();
                return addr.SendCANMessage(msg::kAngularPositionOutput, (uint8_t*) &data, 8);
            }

        };

        /** Angular velocity frame struct */
        struct AngularVelocityOutput {
          public:
            /** Yaw velocity */
            int16_t yaw;

            /** Pitch velocity */
            int16_t pitch;

            /** Roll velocity */
            int16_t roll;

            /**
             * Decodes a struct.
             * 
             * @param data intfield to decode
             * @return a decoded struct
             */
            static constexpr AngularVelocityOutput decode(uint64_t data) {
                return AngularVelocityOutput {
                    .yaw = redux::canand::utils::extractI16(data, 16, 0),
                    .pitch = redux::canand::utils::extractI16(data, 16, 16),
                    .roll = redux::canand::utils::extractI16(data, 16, 32),  
                };
            }

            /**
             * Encodes a struct.
             *
             * @return an encoded struct.
             */
            constexpr uint64_t encode() {
                return (
                    0 |
                    redux::canand::utils::packInt(this->yaw, 16, 0) |
                    redux::canand::utils::packInt(this->pitch, 16, 16) |
                    redux::canand::utils::packInt(this->roll, 16, 32) 
                );
            }


            /** Minimum acceptable data length code for this message */
            static const uint32_t DLC_MIN = 6;

            /** Maximum acceptable data length code for this message */
            static const uint32_t DLC_MAX = 6;

            /**
             * Sends the message struct to a CanandAddress.
             * @param addr the address to send to
             * @return the return value of SendCANMessage
             */
            inline bool send(redux::canand::CanandAddress& addr) {
                uint64_t data = this->encode();
                return addr.SendCANMessage(msg::kAngularVelocityOutput, (uint8_t*) &data, 6);
            }

        };

        /** Acceleration frame struct */
        struct AccelerationOutput {
          public:
            /** Z-axis acceleration */
            int16_t z;

            /** Y-axis acceleration */
            int16_t y;

            /** X-axis acceleration */
            int16_t x;

            /**
             * Decodes a struct.
             * 
             * @param data intfield to decode
             * @return a decoded struct
             */
            static constexpr AccelerationOutput decode(uint64_t data) {
                return AccelerationOutput {
                    .z = redux::canand::utils::extractI16(data, 16, 0),
                    .y = redux::canand::utils::extractI16(data, 16, 16),
                    .x = redux::canand::utils::extractI16(data, 16, 32),  
                };
            }

            /**
             * Encodes a struct.
             *
             * @return an encoded struct.
             */
            constexpr uint64_t encode() {
                return (
                    0 |
                    redux::canand::utils::packInt(this->z, 16, 0) |
                    redux::canand::utils::packInt(this->y, 16, 16) |
                    redux::canand::utils::packInt(this->x, 16, 32) 
                );
            }


            /** Minimum acceptable data length code for this message */
            static const uint32_t DLC_MIN = 6;

            /** Maximum acceptable data length code for this message */
            static const uint32_t DLC_MAX = 6;

            /**
             * Sends the message struct to a CanandAddress.
             * @param addr the address to send to
             * @return the return value of SendCANMessage
             */
            inline bool send(redux::canand::CanandAddress& addr) {
                uint64_t data = this->encode();
                return addr.SendCANMessage(msg::kAccelerationOutput, (uint8_t*) &data, 6);
            }

        };

        /** Trigger Calibration struct */
        struct Calibrate {
          public:
            /** Calibration type */
            uint8_t calibration_type;

            /**
             * Decodes a struct.
             * 
             * @param data intfield to decode
             * @return a decoded struct
             */
            static constexpr Calibrate decode(uint64_t data) {
                return Calibrate {
                    .calibration_type = redux::canand::utils::extractU8(data, 8, 0),  
                };
            }

            /**
             * Encodes a struct.
             *
             * @return an encoded struct.
             */
            constexpr uint64_t encode() {
                return (
                    0 |
                    redux::canand::utils::packUInt(this->calibration_type, 8, 0) 
                );
            }


            /** Minimum acceptable data length code for this message */
            static const uint32_t DLC_MIN = 8;

            /** Maximum acceptable data length code for this message */
            static const uint32_t DLC_MAX = 8;

            /**
             * Sends the message struct to a CanandAddress.
             * @param addr the address to send to
             * @return the return value of SendCANMessage
             */
            inline bool send(redux::canand::CanandAddress& addr) {
                uint64_t data = this->encode();
                return addr.SendCANMessage(msg::kCalibrate, (uint8_t*) &data, 8);
            }

        };

        /** Calibration Status struct */
        struct CalibrationStatus {
          public:

            /**
             * Decodes a struct.
             * 
             * @param data intfield to decode
             * @return a decoded struct
             */
            static constexpr CalibrationStatus decode(uint64_t data) {
                return CalibrationStatus {
  
                };
            }

            /**
             * Encodes a struct.
             *
             * @return an encoded struct.
             */
            constexpr uint64_t encode() {
                return (
                    0 
                );
            }


            /** Minimum acceptable data length code for this message */
            static const uint32_t DLC_MIN = 8;

            /** Maximum acceptable data length code for this message */
            static const uint32_t DLC_MAX = 8;

            /**
             * Sends the message struct to a CanandAddress.
             * @param addr the address to send to
             * @return the return value of SendCANMessage
             */
            inline bool send(redux::canand::CanandAddress& addr) {
                uint64_t data = this->encode();
                return addr.SendCANMessage(msg::kCalibrationStatus, (uint8_t*) &data, 8);
            }

        };

    }

    /** Settings. */
    namespace setting {
        enum : uint8_t {
            /** Status frame period (ms) */
            kStatusFramePeriod = 0x4,

            /** Serial number */
            kSerialNumber = 0x5,

            /** Firmware version */
            kFirmwareVersion = 0x6,

            /** Device-specific type identifier */
            kDeviceType = 0x8,

            /** Yaw angle frame period (ms) */
            kYawFramePeriod = 0xff,

            /** Angular position frame period (ms) */
            kAngularPositionFramePeriod = 0xfe,

            /** Angular velocity frame period (ms) */
            kAngularVelocityFramePeriod = 0xfd,

            /** Acceleration frame period (ms) */
            kAccelerationFramePeriod = 0xfc,

            /** Set yaw */
            kSetYaw = 0xfb,

            /** Set (normed) quaternion assuming positive W */
            kSetPosePositiveW = 0xfa,

            /** Set (normed) quaternion assuming negative W */
            kSetPoseNegativeW = 0xf9,

        };
        /** 
         * Construct setting STATUS_FRAME_PERIOD 
         * @param data the data to pack into a setting bitfield
         * @return 48-bit data field of settings in the wire format
         */
        inline uint64_t constructStatusFramePeriod(uint16_t data) {
            return redux::canand::utils::packUInt(data, 16, 0);
        }

        /** 
         * Unpack setting STATUS_FRAME_PERIOD from the wire format.
         * @param data the 48-bit data field to extract a setting struct from.
         * @return a setting struct
         */
        inline uint16_t extractStatusFramePeriod(uint64_t data) {
            return redux::canand::utils::extractU16(data, 16, 0);
        }

        /** 
         * Construct setting SERIAL_NUMBER 
         * @param data the data to pack into a setting bitfield
         * @return 48-bit data field of settings in the wire format
         */
        inline uint64_t constructSerialNumber(uint64_t data) {
            return redux::canand::utils::packUInt(data, 48, 0);
        }

        /** 
         * Unpack setting SERIAL_NUMBER from the wire format.
         * @param data the 48-bit data field to extract a setting struct from.
         * @return a setting struct
         */
        inline uint64_t extractSerialNumber(uint64_t data) {
            return redux::canand::utils::extractU64(data, 48, 0);
        }

        /** 
         * Construct setting FIRMWARE_VERSION 
         * @param data the data to pack into a setting bitfield
         * @return 48-bit data field of settings in the wire format
         */
        inline uint64_t constructFirmwareVersion(types::FirmwareVersion data) {
            return (data.encode() << 0);
        }

        /** 
         * Unpack setting FIRMWARE_VERSION from the wire format.
         * @param data the 48-bit data field to extract a setting struct from.
         * @return a setting struct
         */
        inline types::FirmwareVersion extractFirmwareVersion(uint64_t data) {
            return types::FirmwareVersion::decode(data >> 0);
        }

        /** 
         * Construct setting DEVICE_TYPE 
         * @param data the data to pack into a setting bitfield
         * @return 48-bit data field of settings in the wire format
         */
        inline uint64_t constructDeviceType(uint16_t data) {
            return redux::canand::utils::packUInt(data, 16, 0);
        }

        /** 
         * Unpack setting DEVICE_TYPE from the wire format.
         * @param data the 48-bit data field to extract a setting struct from.
         * @return a setting struct
         */
        inline uint16_t extractDeviceType(uint64_t data) {
            return redux::canand::utils::extractU16(data, 16, 0);
        }

        /** 
         * Construct setting YAW_FRAME_PERIOD 
         * @param data the data to pack into a setting bitfield
         * @return 48-bit data field of settings in the wire format
         */
        inline uint64_t constructYawFramePeriod(uint16_t data) {
            return redux::canand::utils::packUInt(data, 16, 0);
        }

        /** 
         * Unpack setting YAW_FRAME_PERIOD from the wire format.
         * @param data the 48-bit data field to extract a setting struct from.
         * @return a setting struct
         */
        inline uint16_t extractYawFramePeriod(uint64_t data) {
            return redux::canand::utils::extractU16(data, 16, 0);
        }

        /** 
         * Construct setting ANGULAR_POSITION_FRAME_PERIOD 
         * @param data the data to pack into a setting bitfield
         * @return 48-bit data field of settings in the wire format
         */
        inline uint64_t constructAngularPositionFramePeriod(uint16_t data) {
            return redux::canand::utils::packUInt(data, 16, 0);
        }

        /** 
         * Unpack setting ANGULAR_POSITION_FRAME_PERIOD from the wire format.
         * @param data the 48-bit data field to extract a setting struct from.
         * @return a setting struct
         */
        inline uint16_t extractAngularPositionFramePeriod(uint64_t data) {
            return redux::canand::utils::extractU16(data, 16, 0);
        }

        /** 
         * Construct setting ANGULAR_VELOCITY_FRAME_PERIOD 
         * @param data the data to pack into a setting bitfield
         * @return 48-bit data field of settings in the wire format
         */
        inline uint64_t constructAngularVelocityFramePeriod(uint16_t data) {
            return redux::canand::utils::packUInt(data, 16, 0);
        }

        /** 
         * Unpack setting ANGULAR_VELOCITY_FRAME_PERIOD from the wire format.
         * @param data the 48-bit data field to extract a setting struct from.
         * @return a setting struct
         */
        inline uint16_t extractAngularVelocityFramePeriod(uint64_t data) {
            return redux::canand::utils::extractU16(data, 16, 0);
        }

        /** 
         * Construct setting ACCELERATION_FRAME_PERIOD 
         * @param data the data to pack into a setting bitfield
         * @return 48-bit data field of settings in the wire format
         */
        inline uint64_t constructAccelerationFramePeriod(uint16_t data) {
            return redux::canand::utils::packUInt(data, 16, 0);
        }

        /** 
         * Unpack setting ACCELERATION_FRAME_PERIOD from the wire format.
         * @param data the 48-bit data field to extract a setting struct from.
         * @return a setting struct
         */
        inline uint16_t extractAccelerationFramePeriod(uint64_t data) {
            return redux::canand::utils::extractU16(data, 16, 0);
        }

        /** 
         * Construct setting SET_YAW 
         * @param data the data to pack into a setting bitfield
         * @return 48-bit data field of settings in the wire format
         */
        inline uint64_t constructSetYaw(types::Yaw data) {
            return (data.encode() << 0);
        }

        /** 
         * Unpack setting SET_YAW from the wire format.
         * @param data the 48-bit data field to extract a setting struct from.
         * @return a setting struct
         */
        inline types::Yaw extractSetYaw(uint64_t data) {
            return types::Yaw::decode(data >> 0);
        }

        /** 
         * Construct setting SET_POSE_POSITIVE_W 
         * @param data the data to pack into a setting bitfield
         * @return 48-bit data field of settings in the wire format
         */
        inline uint64_t constructSetPosePositiveW(types::QuatXyz data) {
            return (data.encode() << 0);
        }

        /** 
         * Unpack setting SET_POSE_POSITIVE_W from the wire format.
         * @param data the 48-bit data field to extract a setting struct from.
         * @return a setting struct
         */
        inline types::QuatXyz extractSetPosePositiveW(uint64_t data) {
            return types::QuatXyz::decode(data >> 0);
        }

        /** 
         * Construct setting SET_POSE_NEGATIVE_W 
         * @param data the data to pack into a setting bitfield
         * @return 48-bit data field of settings in the wire format
         */
        inline uint64_t constructSetPoseNegativeW(types::QuatXyz data) {
            return (data.encode() << 0);
        }

        /** 
         * Unpack setting SET_POSE_NEGATIVE_W from the wire format.
         * @param data the 48-bit data field to extract a setting struct from.
         * @return a setting struct
         */
        inline types::QuatXyz extractSetPoseNegativeW(uint64_t data) {
            return types::QuatXyz::decode(data >> 0);
        }


        /**
         * Settings that are required for the vdep to flag all values as received.
         */
        const std::vector<uint8_t> VDEP_SETTINGS = {
            kStatusFramePeriod,
            kYawFramePeriod,
            kAngularPositionFramePeriod,
            kAngularVelocityFramePeriod,
            kAccelerationFramePeriod,
        };

    }
}
